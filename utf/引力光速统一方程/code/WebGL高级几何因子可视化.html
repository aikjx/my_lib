<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGLé«˜çº§å‡ ä½•å› å­å¯è§†åŒ– - å®æ—¶ç‰©ç†æ¨¡æ‹Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #canvas {
            display: block;
            cursor: grab;
            transition: cursor 0.2s;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        #info-panel {
            top: 30px;
            left: 30px;
            width: 420px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #controls-panel {
            top: 30px;
            right: 30px;
            width: 320px;
        }
        
        #math-panel {
            bottom: 30px;
            left: 30px;
            width: 600px;
            max-height: 40vh;
            overflow-y: auto;
        }
        
        #stats-panel {
            bottom: 30px;
            right: 30px;
            width: 280px;
        }
        
        .panel-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .control-group {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            margin: 8px 4px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .button:active {
            transform: translateY(0);
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }
        
        .math-formula.active {
            background: rgba(102, 126, 234, 0.2);
            border-left-color: #feca57;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2, #feca57);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .highlight {
            color: #feca57;
            font-weight: bold;
        }
        
        .warning {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .success {
            color: #51cf66;
            font-weight: bold;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .tooltip {
            position: relative;
            cursor: help;
        }
        
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .pulsing {
            animation: pulse 2s infinite;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                renderActions: {
                    addMenu: [0, '', '']
                }
            }
        };
    </script>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- ä¿¡æ¯é¢æ¿ -->
    <div id="info-panel" class="ui-panel">
        <div class="panel-title">ğŸŒŒ å‡ ä½•å› å­æ¨å¯¼å¯è§†åŒ–</div>
        <div id="current-step-info">
            <h4>å½“å‰æ­¥éª¤: <span id="current-step" class="highlight">åˆå§‹åŒ–</span></h4>
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
            <p id="step-description">æ­£åœ¨è®¾ç½®ä¸‰ç»´ç©ºé—´ä¸­çš„çƒå¯¹ç§°å‘æ•£åœºå’Œç«‹ä½“è§’ç§¯åˆ†å¯è§†åŒ–...</p>
        </div>
        
        <div class="control-group">
            <h4>ğŸ“Š ç§¯åˆ†è¿›åº¦ç›‘æ§</h4>
            <div class="stat-item">
                <span>ç§¯åˆ†å€¼:</span>
                <span id="integral-value" class="highlight">0.000</span>
            </div>
            <div class="stat-item">
                <span>ç†è®ºå€¼ Ï€Â²:</span>
                <span class="success">9.870</span>
            </div>
            <div class="stat-item">
                <span>å‡ ä½•å› å­:</span>
                <span id="geometric-factor" class="highlight">0.000</span>
            </div>
            <div class="stat-item">
                <span>è¯¯å·®:</span>
                <span id="error-value" class="warning">100%</span>
            </div>
        </div>
        
        <div class="control-group">
            <h4>ğŸ¯ ç‰©ç†è§£é‡Š</h4>
            <p id="physics-explanation">
                ç«‹ä½“è§’ç§¯åˆ† âˆ«sin Î¸ dÎ© è¡¨ç¤ºçƒå¯¹ç§°åœºåœ¨äºŒç»´å¹³é¢ä¸Šçš„æŠ•å½±æ€»å’Œã€‚
                è¿™ä¸ªç§¯åˆ†çš„ç»“æœå†³å®šäº†ä»ä¸‰ç»´åˆ°äºŒç»´çš„å‡ ä½•ä¿®æ­£å› å­ã€‚
            </p>
        </div>
    </div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div id="controls-panel" class="ui-panel">
        <div class="panel-title">ğŸ® äº¤äº’æ§åˆ¶</div>
        
        <div class="control-group">
            <button class="button" onclick="startSimulation()">â–¶ï¸ å¼€å§‹æ¨¡æ‹Ÿ</button>
            <button class="button" onclick="pauseSimulation()">â¸ï¸ æš‚åœ</button>
            <button class="button" onclick="resetSimulation()">ğŸ”„ é‡ç½®</button>
        </div>
        
        <div class="control-group">
            <h4>ç§¯åˆ†å‚æ•°æ§åˆ¶</h4>
            <div class="slider-container">
                <label>Î¸ ç§¯åˆ†ä¸Šé™: <span id="theta-limit">Ï€</span></label>
                <input type="range" class="slider" id="theta-slider" min="0" max="180" value="180" 
                       oninput="updateThetaLimit(this.value)">
            </div>
            <div class="slider-container">
                <label>Ï† ç§¯åˆ†ä¸Šé™: <span id="phi-limit">2Ï€</span></label>
                <input type="range" class="slider" id="phi-slider" min="0" max="360" value="360" 
                       oninput="updatePhiLimit(this.value)">
            </div>
            <div class="slider-container">
                <label>ç§¯åˆ†ç²¾åº¦: <span id="precision">100</span></label>
                <input type="range" class="slider" id="precision-slider" min="10" max="500" value="100" 
                       oninput="updatePrecision(this.value)">
            </div>
        </div>
        
        <div class="control-group">
            <h4>å¯è§†åŒ–é€‰é¡¹</h4>
            <div class="checkbox-container">
                <input type="checkbox" id="show-field-lines" checked onchange="toggleFieldLines()">
                <label>æ˜¾ç¤ºåœºçº¿</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="show-integration-region" checked onchange="toggleIntegrationRegion()">
                <label>æ˜¾ç¤ºç§¯åˆ†åŒºåŸŸ</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="show-projection-plane" checked onchange="toggleProjectionPlane()">
                <label>æ˜¾ç¤ºæŠ•å½±å¹³é¢</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="show-particles" checked onchange="toggleParticles()">
                <label>æ˜¾ç¤ºç²’å­ç³»ç»Ÿ</label>
            </div>
        </div>
        
        <div class="control-group">
            <h4>åŠ¨ç”»æ§åˆ¶</h4>
            <div class="slider-container">
                <label>æ—‹è½¬é€Ÿåº¦: <span id="rotation-speed">1.0</span></label>
                <input type="range" class="slider" id="rotation-slider" min="0" max="3" value="1" step="0.1" 
                       oninput="updateRotationSpeed(this.value)">
            </div>
            <div class="slider-container">
                <label>åœºå¼ºå¯è§†åŒ–: <span id="field-intensity">1.0</span></label>
                <input type="range" class="slider" id="field-slider" min="0.1" max="3" value="1" step="0.1" 
                       oninput="updateFieldIntensity(this.value)">
            </div>
        </div>
    </div>
    
    <!-- æ•°å­¦å…¬å¼é¢æ¿ -->
    <div id="math-panel" class="ui-panel">
        <div class="panel-title">ğŸ“ æ•°å­¦æ¨å¯¼è¿‡ç¨‹</div>
        <div id="math-formulas">
            <div class="math-formula" id="formula-1">
                <strong>æ­¥éª¤1: ç«‹ä½“è§’ç§¯åˆ†è®¾ç½®</strong><br>
                æˆ‘ä»¬éœ€è¦è®¡ç®—çƒå¯¹ç§°åœºåœ¨äºŒç»´å¹³é¢ä¸Šçš„æŠ•å½±ï¼š<br>
                $$\int \sin\theta \, d\Omega = \int_0^{2\pi} d\phi \int_0^{\pi} \sin\theta \cdot \sin\theta \, d\theta$$
            </div>
            
            <div class="math-formula" id="formula-2">
                <strong>æ­¥éª¤2: åˆ†ç¦»å˜é‡ç§¯åˆ†</strong><br>
                å°† Ï† å’Œ Î¸ ç§¯åˆ†åˆ†ç¦»ï¼š<br>
                $$= \int_0^{2\pi} d\phi \int_0^{\pi} \sin^2\theta \, d\theta = 2\pi \int_0^{\pi} \sin^2\theta \, d\theta$$
            </div>
            
            <div class="math-formula" id="formula-3">
                <strong>æ­¥éª¤3: è®¡ç®— sinÂ²Î¸ ç§¯åˆ†</strong><br>
                ä½¿ç”¨ç§¯åˆ†å…¬å¼ $\int_0^{\pi} \sin^2\theta \, d\theta = \frac{\pi}{2}$ï¼š<br>
                $$2\pi \int_0^{\pi} \sin^2\theta \, d\theta = 2\pi \cdot \frac{\pi}{2} = \pi^2$$
            </div>
            
            <div class="math-formula" id="formula-4">
                <strong>æ­¥éª¤4: å‡ ä½•å› å­æ¨å¯¼</strong><br>
                å°†ç§¯åˆ†ç»“æœè½¬æ¢ä¸ºå‡ ä½•å› å­ï¼š<br>
                $$\text{å‡ ä½•å› å­} = \frac{\pi^2}{2\pi} \cdot \frac{4\pi}{\pi^2} = \frac{\pi^2 \cdot 4\pi}{2\pi \cdot \pi^2} = \frac{4\pi}{2\pi} = 2$$
            </div>
            
            <div class="math-formula warning" id="formula-5">
                <strong>âš ï¸ é—®é¢˜åˆ†æ</strong><br>
                è¿™ä¸ªæ¨å¯¼å­˜åœ¨æ¦‚å¿µé—®é¢˜ï¼š<br>
                â€¢ ç§¯åˆ†ç»“æœ Ï€Â² æœ‰ç‰¹å®šçš„ç‰©ç†æ„ä¹‰ï¼Œä¸åº”éšæ„è¿›è¡Œé‡çº²è½¬æ¢<br>
                â€¢ å‡ ä½•å› å­åº”è¯¥æ˜¯æ— é‡çº²æ•°ï¼Œä¸”æœ‰æ˜ç¡®çš„ç‰©ç†æ¥æº<br>
                â€¢ æ ‡å‡†ç‰©ç†ä¸­çš„å‡ ä½•å› å­é€šå¸¸æ¥è‡ªç«‹ä½“è§’æ¯”å€¼æˆ–å¯¹ç§°æ€§è€ƒè™‘
            </div>
        </div>
    </div>
    
    <!-- ç»Ÿè®¡é¢æ¿ -->
    <div id="stats-panel" class="ui-panel">
        <div class="panel-title">ğŸ“ˆ å®æ—¶ç»Ÿè®¡</div>
        <div id="performance-stats">
            <div class="stat-item">
                <span>FPS:</span>
                <span id="fps-counter" class="highlight">60</span>
            </div>
            <div class="stat-item">
                <span>ç²’å­æ•°:</span>
                <span id="particle-count" class="highlight">1000</span>
            </div>
            <div class="stat-item">
                <span>åœºçº¿æ•°:</span>
                <span id="field-line-count" class="highlight">50</span>
            </div>
            <div class="stat-item">
                <span>æ¸²æŸ“æ—¶é—´:</span>
                <span id="render-time" class="highlight">16ms</span>
            </div>
        </div>
        
        <div class="control-group">
            <h4>ğŸ”¬ æ•°å€¼éªŒè¯</h4>
            <div class="stat-item">
                <span>æ•°å€¼ç§¯åˆ†:</span>
                <span id="numerical-integral" class="highlight">0.000</span>
            </div>
            <div class="stat-item">
                <span>è§£æè§£:</span>
                <span class="success">9.870</span>
            </div>
            <div class="stat-item">
                <span>ç›¸å¯¹è¯¯å·®:</span>
                <span id="relative-error" class="warning">100%</span>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, stats;
        let sphericalField, projectionPlane, integrationRegion;
        let fieldLines = [], particles = [];
        let animationId, isSimulating = false;
        let integralProgress = 0, currentStep = 0;
        let rotationSpeed = 1, fieldIntensity = 1;
        let thetaLimit = Math.PI, phiLimit = 2 * Math.PI, precision = 100;
        
        // ç‰©ç†å¸¸æ•°
        const MASS_M_POS = new THREE.Vector3(-4, 0, 0);
        const MASS_m_POS = new THREE.Vector3(4, 0, 0);
        const FIELD_RADIUS = 5;
        
        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 8, 12);
            camera.lookAt(0, 0, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // æ€§èƒ½ç›‘æ§
            stats = new Stats();
            stats.showPanel(0);
            document.body.appendChild(stats.dom);
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '10px';
            stats.dom.style.left = '50%';
            stats.dom.style.transform = 'translateX(-50%)';
            
            // è®¾ç½®å…‰ç…§
            setupAdvancedLighting();
            
            // åˆ›å»ºç‰©ç†å¯¹è±¡
            createMasses();
            createSphericalField();
            createProjectionPlane();
            createFieldLines();
            createParticleSystem();
            createIntegrationRegion();
            
            // è®¾ç½®æ§åˆ¶
            setupAdvancedControls();
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
            
            updateStepInfo(0, "åˆå§‹åŒ–å®Œæˆ", "ä¸‰ç»´çƒå¯¹ç§°å‘æ•£åœºå’Œç«‹ä½“è§’ç§¯åˆ†å¯è§†åŒ–å·²å‡†å¤‡å°±ç»ª");
        }
        
        function setupAdvancedLighting() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);
            
            // ä¸»æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(15, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // è´¨é‡Mçš„ç‚¹å…‰æº
            const pointLight1 = new THREE.PointLight(0xff4444, 2, 15);
            pointLight1.position.copy(MASS_M_POS);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            // è´¨é‡mçš„ç‚¹å…‰æº
            const pointLight2 = new THREE.PointLight(0x4444ff, 1.5, 12);
            pointLight2.position.copy(MASS_m_POS);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // ç¯å¢ƒå…‰å¢å¼º
            const hemisphereLight = new THREE.HemisphereLight(0x4040ff, 0x404040, 0.6);
            scene.add(hemisphereLight);
        }
        
        function createMasses() {
            // è´¨é‡M - ä½¿ç”¨é«˜è´¨é‡æè´¨
            const massM_geometry = new THREE.SphereGeometry(0.5, 64, 64);
            const massM_material = new THREE.MeshPhysicalMaterial({
                color: 0xff4444,
                metalness: 0.3,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transparent: true,
                opacity: 0.9
            });
            const massM = new THREE.Mesh(massM_geometry, massM_material);
            massM.position.copy(MASS_M_POS);
            massM.castShadow = true;
            massM.receiveShadow = true;
            scene.add(massM);
            
            // è´¨é‡m
            const massm_geometry = new THREE.SphereGeometry(0.3, 64, 64);
            const massm_material = new THREE.MeshPhysicalMaterial({
                color: 0x4444ff,
                metalness: 0.3,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transparent: true,
                opacity: 0.9
            });
            const massm = new THREE.Mesh(massm_geometry, massm_material);
            massm.position.copy(MASS_m_POS);
            massm.castShadow = true;
            massm.receiveShadow = true;
            scene.add(massm);
            
            // æ·»åŠ å‘å…‰æ•ˆæœ
            createGlowEffect(massM, 0xff4444, 1.2);
            createGlowEffect(massm, 0x4444ff, 0.8);
        }
        
        function createGlowEffect(object, color, intensity) {
            const glowGeometry = object.geometry.clone();
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    c: { type: "f", value: intensity },
                    p: { type: "f", value: 2.0 },
                    glowColor: { type: "c", value: new THREE.Color(color) }
                },
                vertexShader: `
                    uniform float c;
                    uniform float p;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * position);
                        intensity = pow(c - dot(vNormal, vNormel), p);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        vec3 glow = glowColor * intensity;
                        gl_FragColor = vec4(glow, 1.0);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.position.copy(object.position);
            glowMesh.scale.multiplyScalar(1.2);
            scene.add(glowMesh);
        }
        
        function createSphericalField() {
            sphericalField = new THREE.Group();
            
            // åˆ›å»ºè´¨é‡Mçš„å¼•åŠ›åœºï¼ˆçº¢è‰²ç³»ï¼‰
            for (let i = 1; i <= 6; i++) {
                const radius = i * 0.9;
                const geometry = new THREE.SphereGeometry(radius, 64, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.0, 0.8, 0.6 - i * 0.08),
                    transparent: true,
                    opacity: 0.15 - i * 0.02,
                    wireframe: true,
                    wireframeLinewidth: 1.5
                });
                
                const sphereM = new THREE.Mesh(geometry, material);
                sphereM.position.copy(MASS_M_POS);
                sphereM.userData = { massType: 'M' };
                sphericalField.add(sphereM);
            }
            
            // åˆ›å»ºè´¨é‡mçš„å¼•åŠ›åœºï¼ˆè“è‰²ç³»ï¼‰
            for (let i = 1; i <= 4; i++) {
                const radius = i * 0.7;
                const geometry = new THREE.SphereGeometry(radius, 48, 24);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.67, 0.8, 0.6 - i * 0.1),
                    transparent: true,
                    opacity: 0.12 - i * 0.02,
                    wireframe: true,
                    wireframeLinewidth: 1.2
                });
                
                const spherem = new THREE.Mesh(geometry, material);
                spherem.position.copy(MASS_m_POS);
                spherem.userData = { massType: 'm' };
                sphericalField.add(spherem);
            }
            
            // åˆ›å»ºç›¸äº’ä½œç”¨åŒºåŸŸï¼ˆç»¿è‰²ï¼‰
            const interactionGeometry = new THREE.SphereGeometry(1.5, 32, 16);
            const interactionMaterial = new THREE.MeshBasicMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.1,
                wireframe: true
            });
            
            const interactionSphere = new THREE.Mesh(interactionGeometry, interactionMaterial);
            interactionSphere.position.set(0, 0, 0); // ä¸­å¿ƒä½ç½®
            interactionSphere.userData = { massType: 'interaction' };
            sphericalField.add(interactionSphere);
            
            scene.add(sphericalField);
        }
        
        function createProjectionPlane() {
            // ä¸»æŠ•å½±å¹³é¢
            const planeGeometry = new THREE.PlaneGeometry(16, 12, 32, 24);
            const planeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide,
                roughness: 0.1,
                metalness: 0.1,
                clearcoat: 0.5
            });
            
            projectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            projectionPlane.rotation.x = Math.PI / 2;
            projectionPlane.receiveShadow = true;
            scene.add(projectionPlane);
            
            // ç½‘æ ¼è¾…åŠ©çº¿
            const gridHelper = new THREE.GridHelper(16, 32, 0x44ff44, 0x44ff44);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.4;
            scene.add(gridHelper);
            
            // åæ ‡è½´
            const axesHelper = new THREE.AxesHelper(8);
            scene.add(axesHelper);
        }
        
        function createFieldLines() {
            fieldLines = [];
            
            // åˆ›å»ºè´¨é‡Mçš„å¼•åŠ›åœºçº¿ï¼ˆçº¢è‰²ï¼Œå‘å†…æ”¶æ•›ï¼‰
            createGravityFieldLines(MASS_M_POS, 30, 0xff4444, 'M');
            
            // åˆ›å»ºè´¨é‡mçš„å¼•åŠ›åœºçº¿ï¼ˆè“è‰²ï¼Œå‘å†…æ”¶æ•›ï¼‰
            createGravityFieldLines(MASS_m_POS, 20, 0x4444ff, 'm');
            
            // åˆ›å»ºç›¸äº’ä½œç”¨åœºçº¿ï¼ˆé»„è‰²ï¼Œè¿æ¥ä¸¤ä¸ªè´¨é‡ï¼‰
            createInteractionFieldLines();
        }
        
        function createGravityFieldLines(centerPos, lineCount, color, massType) {
            for (let i = 0; i < lineCount; i++) {
                const theta = Math.random() * Math.PI;
                const phi = Math.random() * Math.PI * 2;
                
                // å¼•åŠ›åœºçº¿åº”è¯¥å‘è´¨é‡ä¸­å¿ƒæ”¶æ•›ï¼Œè€Œä¸æ˜¯å‘æ•£
                const direction = new THREE.Vector3(
                    Math.sin(theta) * Math.cos(phi),
                    Math.sin(theta) * Math.sin(phi),
                    Math.cos(theta)
                );
                
                const points = [];
                const maxRadius = massType === 'M' ? 6 : 4;
                
                // ä»å¤–å‘å†…åˆ›å»ºæ”¶æ•›çš„å¼•åŠ›åœºçº¿
                for (let j = 0; j <= 50; j++) {
                    const t = j / 50;
                    const radius = maxRadius * (1 - t * 0.9); // å‘å†…æ”¶æ•›
                    const curvature = 0.1 * Math.sin(t * Math.PI * 3); // æ·»åŠ è½»å¾®å¼¯æ›²
                    
                    const point = centerPos.clone().add(
                        direction.clone().multiplyScalar(radius + curvature)
                    );
                    points.push(point);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 50, 0.015, 6, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                
                const fieldLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
                fieldLine.userData = { 
                    originalOpacity: 0.6, 
                    theta: theta, 
                    phi: phi, 
                    massType: massType,
                    color: color
                };
                fieldLines.push(fieldLine);
                scene.add(fieldLine);
                
                // æ·»åŠ ç®­å¤´æŒ‡ç¤ºå¼•åŠ›æ–¹å‘ï¼ˆå‘å†…ï¼‰
                const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
                const arrowMaterial = new THREE.MeshBasicMaterial({ color: color });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                
                // ç®­å¤´ä½ç½®åœ¨åœºçº¿ä¸­ç‚¹ï¼ŒæŒ‡å‘è´¨é‡ä¸­å¿ƒ
                const midPoint = points[Math.floor(points.length / 2)];
                arrow.position.copy(midPoint);
                arrow.lookAt(centerPos);
                arrow.userData = { isArrow: true, massType: massType };
                
                fieldLines.push(arrow);
                scene.add(arrow);
            }
        }
        
        function createInteractionFieldLines() {
            // åˆ›å»ºè¿æ¥ä¸¤ä¸ªè´¨é‡çš„ç›¸äº’ä½œç”¨åœºçº¿
            const interactionLines = 8;
            
            for (let i = 0; i < interactionLines; i++) {
                const points = [];
                const t_offset = (i / interactionLines) * Math.PI * 2;
                
                // åˆ›å»ºä»Måˆ°mçš„å¼¯æ›²è·¯å¾„
                for (let j = 0; j <= 30; j++) {
                    const t = j / 30;
                    const basePoint = MASS_M_POS.clone().lerp(MASS_m_POS, t);
                    
                    // æ·»åŠ æ­£å¼¦æ³¢åŠ¨
                    const amplitude = 0.5 * Math.sin(Math.PI * t);
                    const offset = new THREE.Vector3(
                        amplitude * Math.cos(t_offset + t * Math.PI * 2),
                        amplitude * Math.sin(t_offset + t * Math.PI * 2),
                        amplitude * 0.5 * Math.cos(t_offset + t * Math.PI * 4)
                    );
                    
                    points.push(basePoint.add(offset));
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 30, 0.02, 6, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                
                const interactionLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
                interactionLine.userData = { 
                    originalOpacity: 0.8, 
                    massType: 'interaction',
                    isInteraction: true
                };
                fieldLines.push(interactionLine);
                scene.add(interactionLine);
                
                // æ·»åŠ åŒå‘ç®­å¤´è¡¨ç¤ºç›¸äº’ä½œç”¨
                const arrowGeometry = new THREE.ConeGeometry(0.06, 0.25, 8);
                
                // æŒ‡å‘mçš„ç®­å¤´
                const arrow1 = new THREE.Mesh(arrowGeometry, new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
                arrow1.position.copy(points[Math.floor(points.length * 0.7)]);
                arrow1.lookAt(MASS_m_POS);
                arrow1.userData = { isArrow: true, massType: 'interaction' };
                fieldLines.push(arrow1);
                scene.add(arrow1);
                
                // æŒ‡å‘Mçš„ç®­å¤´
                const arrow2 = new THREE.Mesh(arrowGeometry, new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
                arrow2.position.copy(points[Math.floor(points.length * 0.3)]);
                arrow2.lookAt(MASS_M_POS);
                arrow2.userData = { isArrow: true, massType: 'interaction' };
                fieldLines.push(arrow2);
                scene.add(arrow2);
            }
        }
        
        function createParticleSystem() {
            particles = [];
            const particleCount = 1000;
            
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                // åœ¨çƒé¢ä¸Šéšæœºåˆ†å¸ƒç²’å­
                const theta = Math.random() * Math.PI;
                const phi = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 4;
                
                positions[i * 3] = MASS_M_POS.x + radius * Math.sin(theta) * Math.cos(phi);
                positions[i * 3 + 1] = MASS_M_POS.y + radius * Math.sin(theta) * Math.sin(phi);
                positions[i * 3 + 2] = MASS_M_POS.z + radius * Math.cos(theta);
                
                const color = new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 0.8, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                sizes[i] = Math.random() * 3 + 1;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + 0.5 * sin(time + position.x));
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            particles.push(particleSystem);
            scene.add(particleSystem);
        }
        
        function createIntegrationRegion() {
            integrationRegion = new THREE.Group();
            
            // åˆ›å»ºç§¯åˆ†åŒºåŸŸçš„å¯è§†åŒ–
            const segmentCount = 20;
            for (let i = 0; i < segmentCount; i++) {
                for (let j = 0; j < segmentCount; j++) {
                    const theta = (i / segmentCount) * Math.PI;
                    const phi = (j / segmentCount) * Math.PI * 2;
                    
                    const geometry = new THREE.ConeGeometry(0.1, 1, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(phi / (Math.PI * 2), 1, 0.5 + 0.3 * Math.sin(theta)),
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const cone = new THREE.Mesh(geometry, material);
                    cone.position.copy(MASS_M_POS);
                    
                    const direction = new THREE.Vector3(
                        Math.sin(theta) * Math.cos(phi),
                        Math.sin(theta) * Math.sin(phi),
                        Math.cos(theta)
                    );
                    
                    cone.lookAt(MASS_M_POS.clone().add(direction));
                    cone.userData = { theta: theta, phi: phi, originalOpacity: 0.6 };
                    
                    integrationRegion.add(cone);
                }
            }
            
            scene.add(integrationRegion);
        }
        
        function setupAdvancedControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            const canvas = document.getElementById('canvas');
            
            // é¼ æ ‡æ§åˆ¶
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y
                    };
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaMove.x * 0.01;
                    spherical.phi += deltaMove.y * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(8, 100);
            });
            
            // é”®ç›˜æ§åˆ¶
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        isSimulating ? pauseSimulation() : startSimulation();
                        break;
                    case 'KeyR':
                        resetSimulation();
                        break;
                    case 'KeyF':
                        toggleFullscreen();
                        break;
                }
            });
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            stats.begin();
            
            const time = Date.now() * 0.001;
            
            if (isSimulating) {
                // æ›´æ–°çƒé¢åœºæ—‹è½¬
                if (sphericalField) {
                    sphericalField.rotation.y += 0.01 * rotationSpeed;
                    sphericalField.rotation.z += 0.005 * rotationSpeed;
                }
                
                // æ›´æ–°åœºçº¿åŠ¨ç”»
                updateFieldLinesAnimation(time);
                
                // æ›´æ–°ç²’å­ç³»ç»Ÿ
                updateParticleSystem(time);
                
                // æ›´æ–°ç§¯åˆ†å¯è§†åŒ–
                updateIntegrationVisualization(time);
                
                // æ›´æ–°ç§¯åˆ†è®¡ç®—
                updateIntegralCalculation();
            }
            
            renderer.render(scene, camera);
            stats.end();
            
            // æ›´æ–°æ€§èƒ½ç»Ÿè®¡
            updatePerformanceStats();
        }
        
        function updateFieldLinesAnimation(time) {
            fieldLines.forEach((line, index) => {
                const userData = line.userData;
                const phase = (index / fieldLines.length) * Math.PI * 2;
                const intensity = (Math.sin(time * 2 + phase) + 1) * 0.5;
                
                line.material.opacity = userData.originalOpacity * (0.3 + intensity * 0.7) * fieldIntensity;
                
                // æ ¹æ®ç§¯åˆ†è¿›åº¦æ˜¾ç¤ºåœºçº¿
                const shouldShow = (userData.theta / Math.PI) <= (integralProgress / 100);
                line.visible = shouldShow && document.getElementById('show-field-lines').checked;
            });
        }
        
        function updateParticleSystem(time) {
            particles.forEach(system => {
                system.material.uniforms.time.value = time;
                
                const positions = system.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    // æ·»åŠ è½»å¾®çš„æ³¢åŠ¨æ•ˆæœ
                    positions[i + 1] += Math.sin(time + i * 0.01) * 0.01;
                }
                system.geometry.attributes.position.needsUpdate = true;
            });
        }
        
        function updateIntegrationVisualization(time) {
            if (integrationRegion) {
                integrationRegion.children.forEach((cone, index) => {
                    const userData = cone.userData;
                    const progress = integralProgress / 100;
                    
                    // æ ¹æ®ç§¯åˆ†è¿›åº¦æ˜¾ç¤ºç§¯åˆ†åŒºåŸŸ
                    const thetaProgress = userData.theta / Math.PI;
                    const phiProgress = userData.phi / (Math.PI * 2);
                    
                    const shouldShow = thetaProgress <= progress && phiProgress <= progress;
                    cone.visible = shouldShow && document.getElementById('show-integration-region').checked;
                    
                    if (shouldShow) {
                        cone.material.opacity = userData.originalOpacity * 
                            (0.5 + 0.5 * Math.sin(time * 3 + index * 0.1));
                    }
                });
            }
        }
        
        function updateIntegralCalculation() {
            // æ•°å€¼ç§¯åˆ†è®¡ç®—
            const thetaSteps = Math.floor(precision);
            const phiSteps = Math.floor(precision);
            let numericalIntegral = 0;
            
            for (let i = 0; i < thetaSteps; i++) {
                for (let j = 0; j < phiSteps; j++) {
                    const theta = (i / thetaSteps) * thetaLimit;
                    const phi = (j / phiSteps) * phiLimit;
                    
                    const dTheta = thetaLimit / thetaSteps;
                    const dPhi = phiLimit / phiSteps;
                    
                    numericalIntegral += Math.sin(theta) * Math.sin(theta) * dTheta * dPhi;
                }
            }
            
            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('integral-value').textContent = numericalIntegral.toFixed(3);
            document.getElementById('numerical-integral').textContent = numericalIntegral.toFixed(3);
            
            const theoreticalValue = Math.PI * Math.PI;
            const error = Math.abs(numericalIntegral - theoreticalValue) / theoreticalValue * 100;
            document.getElementById('error-value').textContent = error.toFixed(1) + '%';
            document.getElementById('relative-error').textContent = error.toFixed(1) + '%';
            
            // è®¡ç®—å‡ ä½•å› å­
            const geometricFactor = (numericalIntegral / (2 * Math.PI)) * (4 * Math.PI / numericalIntegral);
            document.getElementById('geometric-factor').textContent = geometricFactor.toFixed(3);
        }
        
        function updatePerformanceStats() {
            document.getElementById('fps-counter').textContent = Math.round(1000 / stats.domElement.children[0].children[1].textContent);
            document.getElementById('particle-count').textContent = particles.reduce((sum, system) => sum + system.geometry.attributes.position.count, 0);
            document.getElementById('field-line-count').textContent = fieldLines.length;
            document.getElementById('render-time').textContent = stats.domElement.children[0].children[1].textContent + 'ms';
        }
        
        // æ§åˆ¶å‡½æ•°
        function startSimulation() {
            isSimulating = true;
            updateStepInfo(25, "å¼€å§‹ç§¯åˆ†è®¡ç®—", "æ­£åœ¨æ‰§è¡Œç«‹ä½“è§’ç§¯åˆ† âˆ«sin Î¸ dÎ© çš„æ•°å€¼è®¡ç®—");
            highlightFormula(1);
        }
        
        function pauseSimulation() {
            isSimulating = false;
            updateStepInfo(50, "æ¨¡æ‹Ÿå·²æš‚åœ", "å¯ä»¥è°ƒèŠ‚å‚æ•°è§‚å¯Ÿä¸åŒæ¡ä»¶ä¸‹çš„ç§¯åˆ†ç»“æœ");
        }
        
        function resetSimulation() {
            isSimulating = false;
            integralProgress = 0;
            currentStep = 0;
            
            // é‡ç½®æ‰€æœ‰æ»‘å—
            document.getElementById('theta-slider').value = 180;
            document.getElementById('phi-slider').value = 360;
            document.getElementById('precision-slider').value = 100;
            
            updateThetaLimit(180);
            updatePhiLimit(360);
            updatePrecision(100);
            
            updateStepInfo(0, "é‡ç½®å®Œæˆ", "æ‰€æœ‰å‚æ•°å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€");
            highlightFormula(0);
        }
        
        function updateThetaLimit(value) {
            thetaLimit = (parseFloat(value) / 180) * Math.PI;
            document.getElementById('theta-limit').textContent = value + 'Â°';
            integralProgress = (parseFloat(value) / 180) * 100;
            updateProgressBar();
        }
        
        function updatePhiLimit(value) {
            phiLimit = (parseFloat(value) / 180) * Math.PI;
            document.getElementById('phi-limit').textContent = value + 'Â°';
        }
        
        function updatePrecision(value) {
            precision = parseFloat(value);
            document.getElementById('precision').textContent = value;
        }
        
        function updateRotationSpeed(value) {
            rotationSpeed = parseFloat(value);
            document.getElementById('rotation-speed').textContent = value;
        }
        
        function updateFieldIntensity(value) {
            fieldIntensity = parseFloat(value);
            document.getElementById('field-intensity').textContent = value;
        }
        
        function toggleFieldLines() {
            const show = document.getElementById('show-field-lines').checked;
            fieldLines.forEach(line => line.visible = show);
        }
        
        function toggleIntegrationRegion() {
            const show = document.getElementById('show-integration-region').checked;
            if (integrationRegion) {
                integrationRegion.visible = show;
            }
        }
        
        function toggleProjectionPlane() {
            const show = document.getElementById('show-projection-plane').checked;
            if (projectionPlane) {
                projectionPlane.visible = show;
            }
        }
        
        function toggleParticles() {
            const show = document.getElementById('show-particles').checked;
            particles.forEach(system => system.visible = show);
        }
        
        function updateStepInfo(progress, step, description) {
            document.getElementById('current-step').textContent = step;
            document.getElementById('step-description').textContent = description;
            document.getElementById('progress-fill').style.width = progress + '%';
            
            // æ›´æ–°ç‰©ç†è§£é‡Š
            const explanations = [
                "ç«‹ä½“è§’ç§¯åˆ† âˆ«sin Î¸ dÎ© è¡¨ç¤ºçƒå¯¹ç§°åœºåœ¨äºŒç»´å¹³é¢ä¸Šçš„æŠ•å½±æ€»å’Œã€‚è¿™ä¸ªç§¯åˆ†çš„ç»“æœå†³å®šäº†ä»ä¸‰ç»´åˆ°äºŒç»´çš„å‡ ä½•ä¿®æ­£å› å­ã€‚",
                "æ­£åœ¨è®¡ç®— Ï† æ–¹å‘çš„ç§¯åˆ†ã€‚Ï† ä» 0 åˆ° 2Ï€ çš„ç§¯åˆ†ç»“æœä¸º 2Ï€ï¼Œè¿™åæ˜ äº†çƒå¯¹ç§°æ€§ã€‚",
                "æ­£åœ¨è®¡ç®— Î¸ æ–¹å‘çš„ç§¯åˆ†ã€‚âˆ«â‚€^Ï€ sinÂ²Î¸ dÎ¸ = Ï€/2ï¼Œè¿™æ˜¯å…³é”®çš„å‡ ä½•ç§¯åˆ†ã€‚",
                "ç§¯åˆ†è®¡ç®—å®Œæˆã€‚ç»“æœ Ï€Â² â‰ˆ 9.87ï¼Œä½†å°†å…¶è½¬æ¢ä¸ºå‡ ä½•å› å­ 2 çš„è¿‡ç¨‹å­˜åœ¨æ¦‚å¿µé—®é¢˜ã€‚",
                "å‡ ä½•å› å­æ¨å¯¼å®Œæˆï¼Œä½†éœ€è¦æ³¨æ„è¿™ç§æ¨å¯¼æ–¹æ³•çš„å±€é™æ€§å’Œæ¦‚å¿µé—®é¢˜ã€‚"
            ];
            
            const explanationIndex = Math.floor(progress / 20);
            if (explanations[explanationIndex]) {
                document.getElementById('physics-explanation').textContent = explanations[explanationIndex];
            }
        }
        
        function updateProgressBar() {
            document.getElementById('progress-fill').style.width = integralProgress + '%';
        }
        
        function highlightFormula(index) {
            const formulas = document.querySelectorAll('.math-formula');
            formulas.forEach((formula, i) => {
                formula.classList.remove('active');
                if (i === index) {
                    formula.classList.add('active');
                }
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            initScene();
            
            // ç­‰å¾…MathJaxåŠ è½½å®Œæˆ
            setTimeout(() => {
                if (window.MathJax) {
                    MathJax.typesetPromise().then(() => {
                        console.log('MathJaxæ¸²æŸ“å®Œæˆ');
                    });
                }
            }, 1500);
        });
        
        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (renderer) {
                renderer.dispose();
            }
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL高级几何因子可视化 - 实时物理模拟</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #canvas {
            display: block;
            cursor: grab;
            transition: cursor 0.2s;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        #info-panel {
            top: 30px;
            left: 30px;
            width: 420px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #controls-panel {
            top: 30px;
            right: 30px;
            width: 320px;
        }
        
        #math-panel {
            bottom: 30px;
            left: 30px;
            width: 600px;
            max-height: 40vh;
            overflow-y: auto;
        }
        
        #stats-panel {
            bottom: 30px;
            right: 30px;
            width: 280px;
        }
        
        .panel-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .control-group {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            margin: 8px 4px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .button:active {
            transform: translateY(0);
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }
        
        .math-formula.active {
            background: rgba(102, 126, 234, 0.2);
            border-left-color: #feca57;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2, #feca57);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .highlight {
            color: #feca57;
            font-weight: bold;
        }
        
        .warning {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .success {
            color: #51cf66;
            font-weight: bold;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .tooltip {
            position: relative;
            cursor: help;
        }
        
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .pulsing {
            animation: pulse 2s infinite;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                renderActions: {
                    addMenu: [0, '', '']
                }
            }
        };
    </script>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- 信息面板 -->
    <div id="info-panel" class="ui-panel">
        <div class="panel-title">🌌 几何因子推导可视化</div>
        <div id="current-step-info">
            <h4>当前步骤: <span id="current-step" class="highlight">初始化</span></h4>
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
            <p id="step-description">正在设置三维空间中的球对称发散场和立体角积分可视化...</p>
        </div>
        
        <div class="control-group">
            <h4>📊 积分进度监控</h4>
            <div class="stat-item">
                <span>积分值:</span>
                <span id="integral-value" class="highlight">0.000</span>
            </div>
            <div class="stat-item">
                <span>理论值 π²:</span>
                <span class="success">9.870</span>
            </div>
            <div class="stat-item">
                <span>几何因子:</span>
                <span id="geometric-factor" class="highlight">0.000</span>
            </div>
            <div class="stat-item">
                <span>误差:</span>
                <span id="error-value" class="warning">100%</span>
            </div>
        </div>
        
        <div class="control-group">
            <h4>🎯 物理解释</h4>
            <p id="physics-explanation">
                立体角积分 ∫sin θ dΩ 表示球对称场在二维平面上的投影总和。
                这个积分的结果决定了从三维到二维的几何修正因子。
            </p>
        </div>
    </div>
    
    <!-- 控制面板 -->
    <div id="controls-panel" class="ui-panel">
        <div class="panel-title">🎮 交互控制</div>
        
        <div class="control-group">
            <button class="button" onclick="startSimulation()">▶️ 开始模拟</button>
            <button class="button" onclick="pauseSimulation()">⏸️ 暂停</button>
            <button class="button" onclick="resetSimulation()">🔄 重置</button>
        </div>
        
        <div class="control-group">
            <h4>积分参数控制</h4>
            <div class="slider-container">
                <label>θ 积分上限: <span id="theta-limit">π</span></label>
                <input type="range" class="slider" id="theta-slider" min="0" max="180" value="180" 
                       oninput="updateThetaLimit(this.value)">
            </div>
            <div class="slider-container">
                <label>φ 积分上限: <span id="phi-limit">2π</span></label>
                <input type="range" class="slider" id="phi-slider" min="0" max="360" value="360" 
                       oninput="updatePhiLimit(this.value)">
            </div>
            <div class="slider-container">
                <label>积分精度: <span id="precision">100</span></label>
                <input type="range" class="slider" id="precision-slider" min="10" max="500" value="100" 
                       oninput="updatePrecision(this.value)">
            </div>
        </div>
        
        <div class="control-group">
            <h4>可视化选项</h4>
            <div class="checkbox-container">
                <input type="checkbox" id="show-field-lines" checked onchange="toggleFieldLines()">
                <label>显示场线</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="show-integration-region" checked onchange="toggleIntegrationRegion()">
                <label>显示积分区域</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="show-projection-plane" checked onchange="toggleProjectionPlane()">
                <label>显示投影平面</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="show-particles" checked onchange="toggleParticles()">
                <label>显示粒子系统</label>
            </div>
        </div>
        
        <div class="control-group">
            <h4>动画控制</h4>
            <div class="slider-container">
                <label>旋转速度: <span id="rotation-speed">1.0</span></label>
                <input type="range" class="slider" id="rotation-slider" min="0" max="3" value="1" step="0.1" 
                       oninput="updateRotationSpeed(this.value)">
            </div>
            <div class="slider-container">
                <label>场强可视化: <span id="field-intensity">1.0</span></label>
                <input type="range" class="slider" id="field-slider" min="0.1" max="3" value="1" step="0.1" 
                       oninput="updateFieldIntensity(this.value)">
            </div>
        </div>
    </div>
    
    <!-- 数学公式面板 -->
    <div id="math-panel" class="ui-panel">
        <div class="panel-title">📐 数学推导过程</div>
        <div id="math-formulas">
            <div class="math-formula" id="formula-1">
                <strong>步骤1: 立体角积分设置</strong><br>
                我们需要计算球对称场在二维平面上的投影：<br>
                $$\int \sin\theta \, d\Omega = \int_0^{2\pi} d\phi \int_0^{\pi} \sin\theta \cdot \sin\theta \, d\theta$$
            </div>
            
            <div class="math-formula" id="formula-2">
                <strong>步骤2: 分离变量积分</strong><br>
                将 φ 和 θ 积分分离：<br>
                $$= \int_0^{2\pi} d\phi \int_0^{\pi} \sin^2\theta \, d\theta = 2\pi \int_0^{\pi} \sin^2\theta \, d\theta$$
            </div>
            
            <div class="math-formula" id="formula-3">
                <strong>步骤3: 计算 sin²θ 积分</strong><br>
                使用积分公式 $\int_0^{\pi} \sin^2\theta \, d\theta = \frac{\pi}{2}$：<br>
                $$2\pi \int_0^{\pi} \sin^2\theta \, d\theta = 2\pi \cdot \frac{\pi}{2} = \pi^2$$
            </div>
            
            <div class="math-formula" id="formula-4">
                <strong>步骤4: 几何因子推导</strong><br>
                将积分结果转换为几何因子：<br>
                $$\text{几何因子} = \frac{\pi^2}{2\pi} \cdot \frac{4\pi}{\pi^2} = \frac{\pi^2 \cdot 4\pi}{2\pi \cdot \pi^2} = \frac{4\pi}{2\pi} = 2$$
            </div>
            
            <div class="math-formula warning" id="formula-5">
                <strong>⚠️ 问题分析</strong><br>
                这个推导存在概念问题：<br>
                • 积分结果 π² 有特定的物理意义，不应随意进行量纲转换<br>
                • 几何因子应该是无量纲数，且有明确的物理来源<br>
                • 标准物理中的几何因子通常来自立体角比值或对称性考虑
            </div>
        </div>
    </div>
    
    <!-- 统计面板 -->
    <div id="stats-panel" class="ui-panel">
        <div class="panel-title">📈 实时统计</div>
        <div id="performance-stats">
            <div class="stat-item">
                <span>FPS:</span>
                <span id="fps-counter" class="highlight">60</span>
            </div>
            <div class="stat-item">
                <span>粒子数:</span>
                <span id="particle-count" class="highlight">1000</span>
            </div>
            <div class="stat-item">
                <span>场线数:</span>
                <span id="field-line-count" class="highlight">50</span>
            </div>
            <div class="stat-item">
                <span>渲染时间:</span>
                <span id="render-time" class="highlight">16ms</span>
            </div>
        </div>
        
        <div class="control-group">
            <h4>🔬 数值验证</h4>
            <div class="stat-item">
                <span>数值积分:</span>
                <span id="numerical-integral" class="highlight">0.000</span>
            </div>
            <div class="stat-item">
                <span>解析解:</span>
                <span class="success">9.870</span>
            </div>
            <div class="stat-item">
                <span>相对误差:</span>
                <span id="relative-error" class="warning">100%</span>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let scene, camera, renderer, stats;
        let sphericalField, projectionPlane, integrationRegion;
        let fieldLines = [], particles = [];
        let animationId, isSimulating = false;
        let integralProgress = 0, currentStep = 0;
        let rotationSpeed = 1, fieldIntensity = 1;
        let thetaLimit = Math.PI, phiLimit = 2 * Math.PI, precision = 100;
        
        // 物理常数
        const MASS_M_POS = new THREE.Vector3(-4, 0, 0);
        const MASS_m_POS = new THREE.Vector3(4, 0, 0);
        const FIELD_RADIUS = 5;
        
        // 初始化场景
        function initScene() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 8, 12);
            camera.lookAt(0, 0, 0);
            
            // 创建渲染器
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // 性能监控
            stats = new Stats();
            stats.showPanel(0);
            document.body.appendChild(stats.dom);
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '10px';
            stats.dom.style.left = '50%';
            stats.dom.style.transform = 'translateX(-50%)';
            
            // 设置光照
            setupAdvancedLighting();
            
            // 创建物理对象
            createMasses();
            createSphericalField();
            createProjectionPlane();
            createFieldLines();
            createParticleSystem();
            createIntegrationRegion();
            
            // 设置控制
            setupAdvancedControls();
            
            // 开始渲染循环
            animate();
            
            updateStepInfo(0, "初始化完成", "三维球对称发散场和立体角积分可视化已准备就绪");
        }
        
        function setupAdvancedLighting() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);
            
            // 主方向光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(15, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 质量M的点光源
            const pointLight1 = new THREE.PointLight(0xff4444, 2, 15);
            pointLight1.position.copy(MASS_M_POS);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            // 质量m的点光源
            const pointLight2 = new THREE.PointLight(0x4444ff, 1.5, 12);
            pointLight2.position.copy(MASS_m_POS);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // 环境光增强
            const hemisphereLight = new THREE.HemisphereLight(0x4040ff, 0x404040, 0.6);
            scene.add(hemisphereLight);
        }
        
        function createMasses() {
            // 质量M - 使用高质量材质
            const massM_geometry = new THREE.SphereGeometry(0.5, 64, 64);
            const massM_material = new THREE.MeshPhysicalMaterial({
                color: 0xff4444,
                metalness: 0.3,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transparent: true,
                opacity: 0.9
            });
            const massM = new THREE.Mesh(massM_geometry, massM_material);
            massM.position.copy(MASS_M_POS);
            massM.castShadow = true;
            massM.receiveShadow = true;
            scene.add(massM);
            
            // 质量m
            const massm_geometry = new THREE.SphereGeometry(0.3, 64, 64);
            const massm_material = new THREE.MeshPhysicalMaterial({
                color: 0x4444ff,
                metalness: 0.3,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transparent: true,
                opacity: 0.9
            });
            const massm = new THREE.Mesh(massm_geometry, massm_material);
            massm.position.copy(MASS_m_POS);
            massm.castShadow = true;
            massm.receiveShadow = true;
            scene.add(massm);
            
            // 添加发光效果
            createGlowEffect(massM, 0xff4444, 1.2);
            createGlowEffect(massm, 0x4444ff, 0.8);
        }
        
        function createGlowEffect(object, color, intensity) {
            const glowGeometry = object.geometry.clone();
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    c: { type: "f", value: intensity },
                    p: { type: "f", value: 2.0 },
                    glowColor: { type: "c", value: new THREE.Color(color) }
                },
                vertexShader: `
                    uniform float c;
                    uniform float p;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * position);
                        intensity = pow(c - dot(vNormal, vNormel), p);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        vec3 glow = glowColor * intensity;
                        gl_FragColor = vec4(glow, 1.0);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.position.copy(object.position);
            glowMesh.scale.multiplyScalar(1.2);
            scene.add(glowMesh);
        }
        
        function createSphericalField() {
            sphericalField = new THREE.Group();
            
            // 创建质量M的引力场（红色系）
            for (let i = 1; i <= 6; i++) {
                const radius = i * 0.9;
                const geometry = new THREE.SphereGeometry(radius, 64, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.0, 0.8, 0.6 - i * 0.08),
                    transparent: true,
                    opacity: 0.15 - i * 0.02,
                    wireframe: true,
                    wireframeLinewidth: 1.5
                });
                
                const sphereM = new THREE.Mesh(geometry, material);
                sphereM.position.copy(MASS_M_POS);
                sphereM.userData = { massType: 'M' };
                sphericalField.add(sphereM);
            }
            
            // 创建质量m的引力场（蓝色系）
            for (let i = 1; i <= 4; i++) {
                const radius = i * 0.7;
                const geometry = new THREE.SphereGeometry(radius, 48, 24);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.67, 0.8, 0.6 - i * 0.1),
                    transparent: true,
                    opacity: 0.12 - i * 0.02,
                    wireframe: true,
                    wireframeLinewidth: 1.2
                });
                
                const spherem = new THREE.Mesh(geometry, material);
                spherem.position.copy(MASS_m_POS);
                spherem.userData = { massType: 'm' };
                sphericalField.add(spherem);
            }
            
            // 创建相互作用区域（绿色）
            const interactionGeometry = new THREE.SphereGeometry(1.5, 32, 16);
            const interactionMaterial = new THREE.MeshBasicMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.1,
                wireframe: true
            });
            
            const interactionSphere = new THREE.Mesh(interactionGeometry, interactionMaterial);
            interactionSphere.position.set(0, 0, 0); // 中心位置
            interactionSphere.userData = { massType: 'interaction' };
            sphericalField.add(interactionSphere);
            
            scene.add(sphericalField);
        }
        
        function createProjectionPlane() {
            // 主投影平面
            const planeGeometry = new THREE.PlaneGeometry(16, 12, 32, 24);
            const planeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide,
                roughness: 0.1,
                metalness: 0.1,
                clearcoat: 0.5
            });
            
            projectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            projectionPlane.rotation.x = Math.PI / 2;
            projectionPlane.receiveShadow = true;
            scene.add(projectionPlane);
            
            // 网格辅助线
            const gridHelper = new THREE.GridHelper(16, 32, 0x44ff44, 0x44ff44);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.4;
            scene.add(gridHelper);
            
            // 坐标轴
            const axesHelper = new THREE.AxesHelper(8);
            scene.add(axesHelper);
        }
        
        function createFieldLines() {
            fieldLines = [];
            
            // 创建质量M的引力场线（红色，向内收敛）
            createGravityFieldLines(MASS_M_POS, 30, 0xff4444, 'M');
            
            // 创建质量m的引力场线（蓝色，向内收敛）
            createGravityFieldLines(MASS_m_POS, 20, 0x4444ff, 'm');
            
            // 创建相互作用场线（黄色，连接两个质量）
            createInteractionFieldLines();
        }
        
        function createGravityFieldLines(centerPos, lineCount, color, massType) {
            for (let i = 0; i < lineCount; i++) {
                const theta = Math.random() * Math.PI;
                const phi = Math.random() * Math.PI * 2;
                
                // 引力场线应该向质量中心收敛，而不是发散
                const direction = new THREE.Vector3(
                    Math.sin(theta) * Math.cos(phi),
                    Math.sin(theta) * Math.sin(phi),
                    Math.cos(theta)
                );
                
                const points = [];
                const maxRadius = massType === 'M' ? 6 : 4;
                
                // 从外向内创建收敛的引力场线
                for (let j = 0; j <= 50; j++) {
                    const t = j / 50;
                    const radius = maxRadius * (1 - t * 0.9); // 向内收敛
                    const curvature = 0.1 * Math.sin(t * Math.PI * 3); // 添加轻微弯曲
                    
                    const point = centerPos.clone().add(
                        direction.clone().multiplyScalar(radius + curvature)
                    );
                    points.push(point);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 50, 0.015, 6, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                
                const fieldLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
                fieldLine.userData = { 
                    originalOpacity: 0.6, 
                    theta: theta, 
                    phi: phi, 
                    massType: massType,
                    color: color
                };
                fieldLines.push(fieldLine);
                scene.add(fieldLine);
                
                // 添加箭头指示引力方向（向内）
                const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
                const arrowMaterial = new THREE.MeshBasicMaterial({ color: color });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                
                // 箭头位置在场线中点，指向质量中心
                const midPoint = points[Math.floor(points.length / 2)];
                arrow.position.copy(midPoint);
                arrow.lookAt(centerPos);
                arrow.userData = { isArrow: true, massType: massType };
                
                fieldLines.push(arrow);
                scene.add(arrow);
            }
        }
        
        function createInteractionFieldLines() {
            // 创建连接两个质量的相互作用场线
            const interactionLines = 8;
            
            for (let i = 0; i < interactionLines; i++) {
                const points = [];
                const t_offset = (i / interactionLines) * Math.PI * 2;
                
                // 创建从M到m的弯曲路径
                for (let j = 0; j <= 30; j++) {
                    const t = j / 30;
                    const basePoint = MASS_M_POS.clone().lerp(MASS_m_POS, t);
                    
                    // 添加正弦波动
                    const amplitude = 0.5 * Math.sin(Math.PI * t);
                    const offset = new THREE.Vector3(
                        amplitude * Math.cos(t_offset + t * Math.PI * 2),
                        amplitude * Math.sin(t_offset + t * Math.PI * 2),
                        amplitude * 0.5 * Math.cos(t_offset + t * Math.PI * 4)
                    );
                    
                    points.push(basePoint.add(offset));
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 30, 0.02, 6, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                
                const interactionLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
                interactionLine.userData = { 
                    originalOpacity: 0.8, 
                    massType: 'interaction',
                    isInteraction: true
                };
                fieldLines.push(interactionLine);
                scene.add(interactionLine);
                
                // 添加双向箭头表示相互作用
                const arrowGeometry = new THREE.ConeGeometry(0.06, 0.25, 8);
                
                // 指向m的箭头
                const arrow1 = new THREE.Mesh(arrowGeometry, new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
                arrow1.position.copy(points[Math.floor(points.length * 0.7)]);
                arrow1.lookAt(MASS_m_POS);
                arrow1.userData = { isArrow: true, massType: 'interaction' };
                fieldLines.push(arrow1);
                scene.add(arrow1);
                
                // 指向M的箭头
                const arrow2 = new THREE.Mesh(arrowGeometry, new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
                arrow2.position.copy(points[Math.floor(points.length * 0.3)]);
                arrow2.lookAt(MASS_M_POS);
                arrow2.userData = { isArrow: true, massType: 'interaction' };
                fieldLines.push(arrow2);
                scene.add(arrow2);
            }
        }
        
        function createParticleSystem() {
            particles = [];
            const particleCount = 1000;
            
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                // 在球面上随机分布粒子
                const theta = Math.random() * Math.PI;
                const phi = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 4;
                
                positions[i * 3] = MASS_M_POS.x + radius * Math.sin(theta) * Math.cos(phi);
                positions[i * 3 + 1] = MASS_M_POS.y + radius * Math.sin(theta) * Math.sin(phi);
                positions[i * 3 + 2] = MASS_M_POS.z + radius * Math.cos(theta);
                
                const color = new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 0.8, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                sizes[i] = Math.random() * 3 + 1;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + 0.5 * sin(time + position.x));
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            particles.push(particleSystem);
            scene.add(particleSystem);
        }
        
        function createIntegrationRegion() {
            integrationRegion = new THREE.Group();
            
            // 创建积分区域的可视化
            const segmentCount = 20;
            for (let i = 0; i < segmentCount; i++) {
                for (let j = 0; j < segmentCount; j++) {
                    const theta = (i / segmentCount) * Math.PI;
                    const phi = (j / segmentCount) * Math.PI * 2;
                    
                    const geometry = new THREE.ConeGeometry(0.1, 1, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(phi / (Math.PI * 2), 1, 0.5 + 0.3 * Math.sin(theta)),
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const cone = new THREE.Mesh(geometry, material);
                    cone.position.copy(MASS_M_POS);
                    
                    const direction = new THREE.Vector3(
                        Math.sin(theta) * Math.cos(phi),
                        Math.sin(theta) * Math.sin(phi),
                        Math.cos(theta)
                    );
                    
                    cone.lookAt(MASS_M_POS.clone().add(direction));
                    cone.userData = { theta: theta, phi: phi, originalOpacity: 0.6 };
                    
                    integrationRegion.add(cone);
                }
            }
            
            scene.add(integrationRegion);
        }
        
        function setupAdvancedControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            const canvas = document.getElementById('canvas');
            
            // 鼠标控制
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y
                    };
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaMove.x * 0.01;
                    spherical.phi += deltaMove.y * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // 滚轮缩放
            canvas.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(8, 100);
            });
            
            // 键盘控制
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        isSimulating ? pauseSimulation() : startSimulation();
                        break;
                    case 'KeyR':
                        resetSimulation();
                        break;
                    case 'KeyF':
                        toggleFullscreen();
                        break;
                }
            });
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            stats.begin();
            
            const time = Date.now() * 0.001;
            
            if (isSimulating) {
                // 更新球面场旋转
                if (sphericalField) {
                    sphericalField.rotation.y += 0.01 * rotationSpeed;
                    sphericalField.rotation.z += 0.005 * rotationSpeed;
                }
                
                // 更新场线动画
                updateFieldLinesAnimation(time);
                
                // 更新粒子系统
                updateParticleSystem(time);
                
                // 更新积分可视化
                updateIntegrationVisualization(time);
                
                // 更新积分计算
                updateIntegralCalculation();
            }
            
            renderer.render(scene, camera);
            stats.end();
            
            // 更新性能统计
            updatePerformanceStats();
        }
        
        function updateFieldLinesAnimation(time) {
            fieldLines.forEach((line, index) => {
                const userData = line.userData;
                const phase = (index / fieldLines.length) * Math.PI * 2;
                const intensity = (Math.sin(time * 2 + phase) + 1) * 0.5;
                
                line.material.opacity = userData.originalOpacity * (0.3 + intensity * 0.7) * fieldIntensity;
                
                // 根据积分进度显示场线
                const shouldShow = (userData.theta / Math.PI) <= (integralProgress / 100);
                line.visible = shouldShow && document.getElementById('show-field-lines').checked;
            });
        }
        
        function updateParticleSystem(time) {
            particles.forEach(system => {
                system.material.uniforms.time.value = time;
                
                const positions = system.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    // 添加轻微的波动效果
                    positions[i + 1] += Math.sin(time + i * 0.01) * 0.01;
                }
                system.geometry.attributes.position.needsUpdate = true;
            });
        }
        
        function updateIntegrationVisualization(time) {
            if (integrationRegion) {
                integrationRegion.children.forEach((cone, index) => {
                    const userData = cone.userData;
                    const progress = integralProgress / 100;
                    
                    // 根据积分进度显示积分区域
                    const thetaProgress = userData.theta / Math.PI;
                    const phiProgress = userData.phi / (Math.PI * 2);
                    
                    const shouldShow = thetaProgress <= progress && phiProgress <= progress;
                    cone.visible = shouldShow && document.getElementById('show-integration-region').checked;
                    
                    if (shouldShow) {
                        cone.material.opacity = userData.originalOpacity * 
                            (0.5 + 0.5 * Math.sin(time * 3 + index * 0.1));
                    }
                });
            }
        }
        
        function updateIntegralCalculation() {
            // 数值积分计算
            const thetaSteps = Math.floor(precision);
            const phiSteps = Math.floor(precision);
            let numericalIntegral = 0;
            
            for (let i = 0; i < thetaSteps; i++) {
                for (let j = 0; j < phiSteps; j++) {
                    const theta = (i / thetaSteps) * thetaLimit;
                    const phi = (j / phiSteps) * phiLimit;
                    
                    const dTheta = thetaLimit / thetaSteps;
                    const dPhi = phiLimit / phiSteps;
                    
                    numericalIntegral += Math.sin(theta) * Math.sin(theta) * dTheta * dPhi;
                }
            }
            
            // 更新显示
            document.getElementById('integral-value').textContent = numericalIntegral.toFixed(3);
            document.getElementById('numerical-integral').textContent = numericalIntegral.toFixed(3);
            
            const theoreticalValue = Math.PI * Math.PI;
            const error = Math.abs(numericalIntegral - theoreticalValue) / theoreticalValue * 100;
            document.getElementById('error-value').textContent = error.toFixed(1) + '%';
            document.getElementById('relative-error').textContent = error.toFixed(1) + '%';
            
            // 计算几何因子
            const geometricFactor = (numericalIntegral / (2 * Math.PI)) * (4 * Math.PI / numericalIntegral);
            document.getElementById('geometric-factor').textContent = geometricFactor.toFixed(3);
        }
        
        function updatePerformanceStats() {
            document.getElementById('fps-counter').textContent = Math.round(1000 / stats.domElement.children[0].children[1].textContent);
            document.getElementById('particle-count').textContent = particles.reduce((sum, system) => sum + system.geometry.attributes.position.count, 0);
            document.getElementById('field-line-count').textContent = fieldLines.length;
            document.getElementById('render-time').textContent = stats.domElement.children[0].children[1].textContent + 'ms';
        }
        
        // 控制函数
        function startSimulation() {
            isSimulating = true;
            updateStepInfo(25, "开始积分计算", "正在执行立体角积分 ∫sin θ dΩ 的数值计算");
            highlightFormula(1);
        }
        
        function pauseSimulation() {
            isSimulating = false;
            updateStepInfo(50, "模拟已暂停", "可以调节参数观察不同条件下的积分结果");
        }
        
        function resetSimulation() {
            isSimulating = false;
            integralProgress = 0;
            currentStep = 0;
            
            // 重置所有滑块
            document.getElementById('theta-slider').value = 180;
            document.getElementById('phi-slider').value = 360;
            document.getElementById('precision-slider').value = 100;
            
            updateThetaLimit(180);
            updatePhiLimit(360);
            updatePrecision(100);
            
            updateStepInfo(0, "重置完成", "所有参数已重置到初始状态");
            highlightFormula(0);
        }
        
        function updateThetaLimit(value) {
            thetaLimit = (parseFloat(value) / 180) * Math.PI;
            document.getElementById('theta-limit').textContent = value + '°';
            integralProgress = (parseFloat(value) / 180) * 100;
            updateProgressBar();
        }
        
        function updatePhiLimit(value) {
            phiLimit = (parseFloat(value) / 180) * Math.PI;
            document.getElementById('phi-limit').textContent = value + '°';
        }
        
        function updatePrecision(value) {
            precision = parseFloat(value);
            document.getElementById('precision').textContent = value;
        }
        
        function updateRotationSpeed(value) {
            rotationSpeed = parseFloat(value);
            document.getElementById('rotation-speed').textContent = value;
        }
        
        function updateFieldIntensity(value) {
            fieldIntensity = parseFloat(value);
            document.getElementById('field-intensity').textContent = value;
        }
        
        function toggleFieldLines() {
            const show = document.getElementById('show-field-lines').checked;
            fieldLines.forEach(line => line.visible = show);
        }
        
        function toggleIntegrationRegion() {
            const show = document.getElementById('show-integration-region').checked;
            if (integrationRegion) {
                integrationRegion.visible = show;
            }
        }
        
        function toggleProjectionPlane() {
            const show = document.getElementById('show-projection-plane').checked;
            if (projectionPlane) {
                projectionPlane.visible = show;
            }
        }
        
        function toggleParticles() {
            const show = document.getElementById('show-particles').checked;
            particles.forEach(system => system.visible = show);
        }
        
        function updateStepInfo(progress, step, description) {
            document.getElementById('current-step').textContent = step;
            document.getElementById('step-description').textContent = description;
            document.getElementById('progress-fill').style.width = progress + '%';
            
            // 更新物理解释
            const explanations = [
                "立体角积分 ∫sin θ dΩ 表示球对称场在二维平面上的投影总和。这个积分的结果决定了从三维到二维的几何修正因子。",
                "正在计算 φ 方向的积分。φ 从 0 到 2π 的积分结果为 2π，这反映了球对称性。",
                "正在计算 θ 方向的积分。∫₀^π sin²θ dθ = π/2，这是关键的几何积分。",
                "积分计算完成。结果 π² ≈ 9.87，但将其转换为几何因子 2 的过程存在概念问题。",
                "几何因子推导完成，但需要注意这种推导方法的局限性和概念问题。"
            ];
            
            const explanationIndex = Math.floor(progress / 20);
            if (explanations[explanationIndex]) {
                document.getElementById('physics-explanation').textContent = explanations[explanationIndex];
            }
        }
        
        function updateProgressBar() {
            document.getElementById('progress-fill').style.width = integralProgress + '%';
        }
        
        function highlightFormula(index) {
            const formulas = document.querySelectorAll('.math-formula');
            formulas.forEach((formula, i) => {
                formula.classList.remove('active');
                if (i === index) {
                    formula.classList.add('active');
                }
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 页面加载完成后初始化
        window.addEventListener('load', () => {
            initScene();
            
            // 等待MathJax加载完成
            setTimeout(() => {
                if (window.MathJax) {
                    MathJax.typesetPromise().then(() => {
                        console.log('MathJax渲染完成');
                    });
                }
            }, 1500);
        });
        
        // 页面卸载时清理资源
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (renderer) {
                renderer.dispose();
            }
        });
    </script>
</body>
</html>
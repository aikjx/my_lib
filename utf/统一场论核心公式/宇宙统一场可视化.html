<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¼ ç¥¥å‰ç»Ÿä¸€åœºè®º - å®‡å®™ç»Ÿä¸€åœºå¯è§†åŒ–</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            overflow: hidden; color: white; height: 100vh;
        }
        
        #canvas { 
            display: block; cursor: grab; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0c0c0c 100%);
        }
        
        .ui-panel {
            position: absolute; background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px; padding: 20px; 
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }
        
        .ui-panel:hover { transform: translateY(-2px); }
        
        #info-panel { 
            top: 20px; left: 20px; width: 450px; max-height: 80vh; overflow-y: auto;
        }
        
        #controls-panel { 
            top: 20px; right: 20px; width: 350px;
        }
        
        #formula-panel {
            bottom: 20px; left: 20px; width: 600px; max-height: 300px; overflow-y: auto;
        }
        
        .panel-title {
            font-size: 1.5em; font-weight: bold; margin-bottom: 15px;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            background-clip: text; -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }
        
        .control-button {
            background: linear-gradient(45deg, #667eea, #764ba2); color: white; 
            border: none; padding: 12px 24px; border-radius: 25px; 
            cursor: pointer; margin: 5px; font-size: 0.9em;
            transition: all 0.3s ease; font-weight: 500;
        }
        
        .control-button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        
        .formula-item {
            background: rgba(255, 255, 255, 0.05); padding: 10px; 
            border-radius: 8px; margin: 8px 0; border-left: 4px solid #667eea;
            cursor: pointer; transition: all 0.3s ease;
        }
        
        .formula-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }
        
        .formula-item.active {
            background: rgba(102, 126, 234, 0.2);
            border-left-color: #f093fb;
        }
        
        .cosmic-insight {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid rgba(102, 126, 234, 0.3); padding: 15px; 
            border-radius: 10px; margin: 15px 0;
        }
        
        .cosmic-insight h4 {
            color: #667eea; margin-bottom: 8px; font-size: 1.1em;
        }
        
        .loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 0.5s ease;
        }
        
        .loading-spinner {
            width: 80px; height: 80px; border: 6px solid rgba(255,255,255,0.1);
            border-top: 6px solid #667eea; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 30px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .fade-out { opacity: 0; pointer-events: none; }
        
        .stats-display {
            background: rgba(255, 255, 255, 0.05); padding: 10px; 
            border-radius: 8px; margin: 10px 0; font-family: monospace;
            font-size: 0.85em; line-height: 1.4;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .ui-panel { width: calc(100% - 40px) !important; }
            #controls-panel { top: auto; bottom: 20px; right: 20px; }
            #formula-panel { display: none; }
        }
    </style>
    
    <!-- å¤–éƒ¨åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
</head>
<body>
    <!-- åŠ è½½å±å¹• -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-spinner"></div>
        <h1>ğŸŒŒ å¼ ç¥¥å‰ç»Ÿä¸€åœºè®º</h1>
        <h2>å®‡å®™ç»Ÿä¸€åœºå¯è§†åŒ–ç³»ç»Ÿ</h2>
        <p>æ­£åœ¨æ„å»ºå®‡å®™çš„æ•°å­¦ç»“æ„...</p>
    </div>
    
    <!-- ä¸»ç”»å¸ƒ -->
    <canvas id="canvas"></canvas>
    
    <!-- ä¿¡æ¯é¢æ¿ -->
    <div id="info-panel" class="ui-panel">
        <div class="panel-title">ğŸŒŒ å®‡å®™ç»Ÿä¸€åœºè®º</div>
        
        <div class="cosmic-insight">
            <h4>ğŸ”¬ æ ¸å¿ƒç†å¿µ</h4>
            <p>å¼ ç¥¥å‰ç»Ÿä¸€åœºè®ºè®¤ä¸ºï¼Œå®‡å®™ä¸­çš„ä¸€åˆ‡ç°è±¡éƒ½æºäº<strong>ç©ºé—´ä»¥å…‰é€Ÿè¿›è¡Œèºæ—‹è¿åŠ¨</strong>è¿™ä¸€åŸºæœ¬äº‹å®ã€‚æ—¶é—´ã€è´¨é‡ã€åŠ›åœºéƒ½æ˜¯è¿™ç§è¿åŠ¨çš„ä¸åŒè¡¨ç°å½¢å¼ã€‚</p>
        </div>
        
        <div class="cosmic-insight">
            <h4>ğŸŒŸ ç†è®ºçªç ´</h4>
            <p>â€¢ <strong>æ—¶ç©ºç»Ÿä¸€</strong>ï¼šæ—¶é—´æ˜¯ç©ºé—´è¿åŠ¨çš„åº¦é‡<br>
            â€¢ <strong>è´¨é‡å‡ ä½•åŒ–</strong>ï¼šè´¨é‡æ˜¯ç©ºé—´æ‰­æ›²çš„åº¦é‡<br>
            â€¢ <strong>å››åŠ›ç»Ÿä¸€</strong>ï¼šæ‰€æœ‰åŠ›éƒ½æºäºåŒä¸€æ–¹ç¨‹<br>
            â€¢ <strong>å¸¸æ•°å…³è”</strong>ï¼šGä¸cå­˜åœ¨æ·±å±‚æ•°å­¦å…³ç³»</p>
        </div>
        
        <div class="cosmic-insight">
            <h4>ğŸš€ æŠ€æœ¯é¢„è¨€</h4>
            <p>â€¢ <strong>åé‡åŠ›æŠ€æœ¯</strong>ï¼šé€šè¿‡è´¨é‡å˜åŒ–äº§ç”Ÿæ¨åŠ›<br>
            â€¢ <strong>å…‰é€Ÿé£è¡Œ</strong>ï¼šåŸºäºç»Ÿä¸€åœºåŸç†çš„æ¨è¿›<br>
            â€¢ <strong>åœºæ“æ§</strong>ï¼šå¼•åŠ›ä¸ç”µç£çš„ç›¸äº’è½¬åŒ–<br>
            â€¢ <strong>æ—¶ç©ºå·¥ç¨‹</strong>ï¼šå¯¹æ—¶ç©ºç»“æ„çš„ç›´æ¥æ“ä½œ</p>
        </div>
        
        <div class="stats-display" id="statsDisplay">
            <strong>å®æ—¶ç»Ÿè®¡ï¼š</strong><br>
            æ´»è·ƒå…¬å¼: <span id="activeFormulas">19</span><br>
            åœºå¼ºåº¦: <span id="fieldStrength">100%</span><br>
            ç»Ÿä¸€åº¦: <span id="unificationLevel">å®Œå…¨ç»Ÿä¸€</span><br>
            å®‡å®™å’Œè°åº¦: <span id="cosmicHarmony">âˆ</span>
        </div>
    </div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div id="controls-panel" class="ui-panel">
        <div class="panel-title">ğŸ® å®‡å®™æ§åˆ¶å°</div>
        
        <div style="text-align: center; margin-bottom: 15px;">
            <button class="control-button" onclick="toggleAnimation()">
                <span id="playPauseIcon">â–¶ï¸</span> <span id="playPauseText">å¯åŠ¨å®‡å®™</span>
            </button>
            <button class="control-button" onclick="resetUniverse()">ğŸ”„ é‡ç½®å®‡å®™</button>
            <button class="control-button" onclick="toggleFullscreen()">ğŸ” å…¨å±è§‚æµ‹</button>
        </div>
        
        <div class="cosmic-insight">
            <h4>ğŸ›ï¸ åœºæ§åˆ¶</h4>
            <button class="control-button" onclick="focusFormula('spacetime')">æ—¶ç©ºåœº</button>
            <button class="control-button" onclick="focusFormula('gravity')">å¼•åŠ›åœº</button>
            <button class="control-button" onclick="focusFormula('electromagnetic')">ç”µç£åœº</button>
            <button class="control-button" onclick="focusFormula('unified')">ç»Ÿä¸€åœº</button>
        </div>
        
        <div class="cosmic-insight">
            <h4>ğŸŒŒ è§‚æµ‹æ¨¡å¼</h4>
            <button class="control-button" onclick="setViewMode('overview')">å…¨æ™¯è§†å›¾</button>
            <button class="control-button" onclick="setViewMode('detailed')">ç»†èŠ‚è§†å›¾</button>
            <button class="control-button" onclick="setViewMode('mathematical')">æ•°å­¦è§†å›¾</button>
        </div>
        
        <div class="cosmic-insight">
            <h4>ğŸ’¡ æ“ä½œæŒ‡å—</h4>
            <p>â€¢ é¼ æ ‡æ‹–æ‹½æ—‹è½¬å®‡å®™<br>
            â€¢ æ»šè½®ç¼©æ”¾è§‚æµ‹è·ç¦»<br>
            â€¢ ç‚¹å‡»å…¬å¼çƒä½“æŸ¥çœ‹è¯¦æƒ…<br>
            â€¢ è§‚å¯Ÿåœºçš„ç›¸äº’ä½œç”¨</p>
        </div>
    </div>
    
    <!-- å…¬å¼é¢æ¿ -->
    <div id="formula-panel" class="ui-panel">
        <div class="panel-title">ğŸ“ æ ¸å¿ƒå…¬å¼å¯¼èˆª</div>
        <div id="formulaList">
            <!-- å…¬å¼åˆ—è¡¨å°†ç”±JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let animationId, isAnimating = false;
        let universeObjects = {};
        let startTime = Date.now();
        let currentFocus = 'all';
        let viewMode = 'overview';
        
        // å…¬å¼æ•°æ®
        const formulas = [
            { id: '01', name: 'æ—¶ç©ºåŒä¸€åŒ–æ–¹ç¨‹', category: 'spacetime', color: 0xffffff, position: [0, 0, 0] },
            { id: '02', name: 'ä¸‰ç»´èºæ—‹æ—¶ç©ºæ–¹ç¨‹', category: 'spacetime', color: 0x667eea, position: [8, 0, 0] },
            { id: '03', name: 'è´¨é‡å®šä¹‰æ–¹ç¨‹', category: 'mass', color: 0xffd700, position: [0, 8, 0] },
            { id: '04', name: 'å¼•åŠ›åœºå®šä¹‰æ–¹ç¨‹', category: 'gravity', color: 0xff6b6b, position: [0, 0, 8] },
            { id: '05', name: 'é™æ­¢åŠ¨é‡æ–¹ç¨‹', category: 'momentum', color: 0x4ecdc4, position: [-8, 0, 0] },
            { id: '06', name: 'è¿åŠ¨åŠ¨é‡æ–¹ç¨‹', category: 'momentum', color: 0x45b7d1, position: [0, -8, 0] },
            { id: '07', name: 'å®‡å®™å¤§ç»Ÿä¸€æ–¹ç¨‹', category: 'unified', color: 0xf093fb, position: [0, 0, -8] },
            { id: '08', name: 'ç©ºé—´æ³¢åŠ¨æ–¹ç¨‹', category: 'wave', color: 0x96ceb4, position: [6, 6, 0] },
            { id: '09', name: 'ç”µè·å®šä¹‰æ–¹ç¨‹', category: 'electromagnetic', color: 0xfeca57, position: [6, 0, 6] },
            { id: '10', name: 'ç”µåœºå®šä¹‰æ–¹ç¨‹', category: 'electromagnetic', color: 0xff9ff3, position: [0, 6, 6] },
            { id: '11', name: 'ç£åœºå®šä¹‰æ–¹ç¨‹', category: 'electromagnetic', color: 0x54a0ff, position: [-6, 6, 0] },
            { id: '12', name: 'å˜åŒ–å¼•åŠ›åœºäº§ç”Ÿç”µç£åœº', category: 'coupling', color: 0xff6348, position: [-6, 0, 6] },
            { id: '13', name: 'ç£çŸ¢åŠ¿æ–¹ç¨‹', category: 'electromagnetic', color: 0x5f27cd, position: [0, -6, 6] },
            { id: '14', name: 'å˜åŒ–å¼•åŠ›åœºäº§ç”Ÿç”µåœº', category: 'coupling', color: 0x00d2d3, position: [6, -6, 0] },
            { id: '15', name: 'å˜åŒ–ç£åœºäº§ç”Ÿå¼•åŠ›åœºå’Œç”µåœº', category: 'coupling', color: 0xff9f43, position: [6, 0, -6] },
            { id: '16', name: 'ç»Ÿä¸€åœºè®ºèƒ½é‡æ–¹ç¨‹', category: 'energy', color: 0xee5a24, position: [0, 6, -6] },
            { id: '17', name: 'å…‰é€Ÿé£è¡Œå™¨åŠ¨åŠ›å­¦æ–¹ç¨‹', category: 'propulsion', color: 0x0abde3, position: [-6, -6, 0] },
            { id: '18', name: 'ç©ºé—´æ³¢åŠ¨é€šè§£', category: 'wave', color: 0x006ba6, position: [-6, 0, -6] },
            { id: '19', name: 'å¼•åŠ›å…‰é€Ÿç»Ÿä¸€æ–¹ç¨‹', category: 'constants', color: 0xc44569, position: [0, -6, -6] }
        ];
        
        // åœºæ™¯åˆå§‹åŒ–
        function initUniverse() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 100, 300);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'), 
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // åˆ›å»ºæ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 200;
            controls.minDistance = 10;
            
            // è®¾ç½®å®‡å®™ç¯å¢ƒ
            setupUniverseEnvironment();
            
            // åˆ›å»ºå…¬å¼çƒä½“
            createFormulaSpheres();
            
            // åˆ›å»ºè¿æ¥çº¿
            createConnections();
            
            // åˆ›å»ºç»Ÿä¸€åœºæ•ˆåº”
            createUnifiedField();
            
            // ç”Ÿæˆå…¬å¼åˆ—è¡¨
            generateFormulaList();
            
            // å¼€å§‹å®‡å®™åŠ¨ç”»
            animateUniverse();
            
            // éšè—åŠ è½½å±å¹•
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('fade-out');
            }, 2000);
        }
        
        // è®¾ç½®å®‡å®™ç¯å¢ƒ
        function setupUniverseEnvironment() {
            // å®‡å®™èƒŒæ™¯å…‰
            const ambientLight = new THREE.AmbientLight(0x404080, 0.2);
            scene.add(ambientLight);
            
            // ä¸­å¿ƒå…‰æºï¼ˆä»£è¡¨ç»Ÿä¸€åœºçš„æ ¸å¿ƒï¼‰
            const centralLight = new THREE.PointLight(0xffffff, 2, 100);
            centralLight.position.set(0, 0, 0);
            centralLight.castShadow = true;
            scene.add(centralLight);
            
            // åˆ›å»ºå®‡å®™åæ ‡ç³»
            const axesHelper = new THREE.AxesHelper(15);
            scene.add(axesHelper);
            
            // åˆ›å»ºå®‡å®™ç½‘æ ¼
            const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
            scene.add(gridHelper);
            
            // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
            createStarField();
        }
        
        // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.55, Math.random() * 0.25 + 0.55);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starMaterial = new THREE.PointsMaterial({ 
                size: 0.5, 
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            universeObjects.stars = stars;
        }
        
        // åˆ›å»ºå…¬å¼çƒä½“
        function createFormulaSpheres() {
            const sphereGroup = new THREE.Group();
            
            formulas.forEach((formula, index) => {
                // åˆ›å»ºçƒä½“å‡ ä½•
                const geometry = new THREE.SphereGeometry(1.5, 32, 16);
                
                // åˆ›å»ºå‘å…‰æè´¨
                const material = new THREE.MeshPhongMaterial({ 
                    color: formula.color,
                    emissive: new THREE.Color(formula.color).multiplyScalar(0.2),
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(...formula.position);
                sphere.userData = formula;
                
                // æ·»åŠ å…‰ç¯æ•ˆæœ
                const ringGeometry = new THREE.RingGeometry(2, 2.5, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: formula.color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                sphere.add(ring);
                
                // æ·»åŠ ç²’å­æ•ˆåº”
                createParticleEffect(sphere, formula.color);
                
                sphereGroup.add(sphere);
            });
            
            scene.add(sphereGroup);
            universeObjects.formulaSpheres = sphereGroup;
        }
        
        // åˆ›å»ºç²’å­æ•ˆåº”
        function createParticleEffect(parent, color) {
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const radius = 3 + Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({ 
                color: color,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            parent.add(particles);
        }
        
        // åˆ›å»ºè¿æ¥çº¿
        function createConnections() {
            const connectionGroup = new THREE.Group();
            
            // å®šä¹‰å…¬å¼é—´çš„é€»è¾‘è¿æ¥
            const connections = [
                ['01', '02'], ['01', '03'], ['01', '05'], ['01', '08'],
                ['03', '04'], ['03', '09'], ['05', '06'], ['06', '07'],
                ['04', '12'], ['04', '14'], ['09', '10'], ['10', '11'],
                ['11', '13'], ['12', '15'], ['14', '15'], ['07', '16'],
                ['07', '17'], ['08', '18'], ['04', '19']
            ];
            
            connections.forEach(([from, to]) => {
                const fromFormula = formulas.find(f => f.id === from);
                const toFormula = formulas.find(f => f.id === to);
                
                if (fromFormula && toFormula) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        ...fromFormula.position,
                        ...toFormula.position
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0x667eea,
                        transparent: true,
                        opacity: 0.4
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    connectionGroup.add(line);
                }
            });
            
            scene.add(connectionGroup);
            universeObjects.connections = connectionGroup;
        }
        
        // åˆ›å»ºç»Ÿä¸€åœºæ•ˆåº”
        function createUnifiedField() {
            // ä¸­å¿ƒç»Ÿä¸€åœºçƒ
            const fieldGeometry = new THREE.SphereGeometry(20, 64, 32);
            const fieldMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 0.1 }
                },
                vertexShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        
                        vec3 newPosition = position + normal * sin(time + length(position) * 0.02) * 0.5;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        float r = length(vPosition);
                        float theta = acos(vPosition.z / r);
                        float phi = atan(vPosition.y, vPosition.x);
                        
                        vec3 color = mix(
                            vec3(0.4, 0.5, 1.0),
                            vec3(1.0, 0.6, 0.8),
                            sin(theta * 3.0 + time) * 0.5 + 0.5
                        );
                        
                        float alpha = opacity * (0.5 + sin(time + r * 0.1) * 0.3);
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const unifiedField = new THREE.Mesh(fieldGeometry, fieldMaterial);
            scene.add(unifiedField);
            universeObjects.unifiedField = unifiedField;
        }
        
        // ç”Ÿæˆå…¬å¼åˆ—è¡¨
        function generateFormulaList() {
            const formulaList = document.getElementById('formulaList');
            
            formulas.forEach(formula => {
                const item = document.createElement('div');
                item.className = 'formula-item';
                item.innerHTML = `
                    <strong>${formula.id}. ${formula.name}</strong><br>
                    <small>ç±»åˆ«: ${formula.category}</small>
                `;
                item.onclick = () => focusOnFormula(formula.id);
                formulaList.appendChild(item);
            });
        }
        
        // ä¸»åŠ¨ç”»å¾ªç¯
        function animateUniverse() {
            animationId = requestAnimationFrame(animateUniverse);
            
            const currentTime = (Date.now() - startTime) / 1000;
            
            if (isAnimating) {
                updateUniverseAnimation(currentTime);
            }
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            
            // æ¸²æŸ“å®‡å®™
            renderer.render(scene, camera);
        }
        
        // æ›´æ–°å®‡å®™åŠ¨ç”»
        function updateUniverseAnimation(time) {
            // æ—‹è½¬å…¬å¼çƒä½“
            if (universeObjects.formulaSpheres) {
                universeObjects.formulaSpheres.children.forEach((sphere, index) => {
                    sphere.rotation.y = time * (0.2 + index * 0.01);
                    sphere.rotation.x = time * (0.1 + index * 0.005);
                    
                    // è½»å¾®çš„ä¸Šä¸‹æµ®åŠ¨
                    const originalY = sphere.userData.position[1];
                    sphere.position.y = originalY + Math.sin(time + index) * 0.5;
                });
            }
            
            // æ›´æ–°ç»Ÿä¸€åœº
            if (universeObjects.unifiedField) {
                universeObjects.unifiedField.material.uniforms.time.value = time;
                universeObjects.unifiedField.rotation.y = time * 0.05;
            }
            
            // æ—‹è½¬æ˜Ÿç©º
            if (universeObjects.stars) {
                universeObjects.stars.rotation.y = time * 0.001;
            }
            
            // æ›´æ–°è¿æ¥çº¿é€æ˜åº¦
            if (universeObjects.connections) {
                universeObjects.connections.children.forEach((line, index) => {
                    line.material.opacity = 0.2 + Math.sin(time + index) * 0.2;
                });
            }
        }
        
        // èšç„¦ç‰¹å®šå…¬å¼
        function focusOnFormula(formulaId) {
            const formula = formulas.find(f => f.id === formulaId);
            if (formula) {
                // ç§»åŠ¨ç›¸æœºåˆ°å…¬å¼ä½ç½®
                const targetPosition = new THREE.Vector3(...formula.position);
                targetPosition.multiplyScalar(1.5);
                
                // å¹³æ»‘ç§»åŠ¨ç›¸æœº
                const startPosition = camera.position.clone();
                const duration = 2000;
                const startTime = Date.now();
                
                function animateCamera() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    controls.target.lerp(new THREE.Vector3(...formula.position), easeProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCamera);
                    }
                }
                
                animateCamera();
                
                // é«˜äº®é€‰ä¸­çš„å…¬å¼
                document.querySelectorAll('.formula-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.formula-item')[formulas.findIndex(f => f.id === formulaId)].classList.add('active');
            }
        }
        
        // èšç„¦ç‰¹å®šç±»åˆ«
        function focusFormula(category) {
            currentFocus = category;
            
            if (universeObjects.formulaSpheres) {
                universeObjects.formulaSpheres.children.forEach(sphere => {
                    const formula = sphere.userData;
                    if (category === 'all' || formula.category === category) {
                        sphere.material.opacity = 0.9;
                        sphere.scale.set(1, 1, 1);
                    } else {
                        sphere.material.opacity = 0.3;
                        sphere.scale.set(0.5, 0.5, 0.5);
                    }
                });
            }
        }
        
        // è®¾ç½®è§‚æµ‹æ¨¡å¼
        function setViewMode(mode) {
            viewMode = mode;
            
            switch (mode) {
                case 'overview':
                    camera.position.set(30, 30, 30);
                    controls.target.set(0, 0, 0);
                    break;
                case 'detailed':
                    camera.position.set(15, 15, 15);
                    break;
                case 'mathematical':
                    camera.position.set(50, 0, 0);
                    camera.lookAt(0, 0, 0);
                    break;
            }
        }
        
        // æ§åˆ¶å‡½æ•°
        function toggleAnimation() {
            isAnimating = !isAnimating;
            const icon = document.getElementById('playPauseIcon');
            const text = document.getElementById('playPauseText');
            
            if (isAnimating) {
                icon.textContent = 'â¸ï¸';
                text.textContent = 'æš‚åœå®‡å®™';
            } else {
                icon.textContent = 'â–¶ï¸';
                text.textContent = 'å¯åŠ¨å®‡å®™';
            }
        }
        
        function resetUniverse() {
            startTime = Date.now();
            camera.position.set(30, 30, 30);
            controls.target.set(0, 0, 0);
            focusFormula('all');
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–å®‡å®™
        window.addEventListener('load', () => {
            initUniverse();
        });
    </script>
</body>
</html>
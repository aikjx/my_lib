<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«‹ä½“è§’ç§¯åˆ†ä¸å‡ ä½•å› å­æ¨å¯¼ - äº¤äº’å¼3Då¯è§†åŒ–</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            color: white;
            min-width: 250px;
        }
        
        #math-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            backdrop-filter: blur(10px);
        }
        
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .math-formula {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        
        .highlight {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        #progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui-panel">
            <h2 style="color: #667eea; margin-top: 0;">ğŸŒŒ ç«‹ä½“è§’ç§¯åˆ†å¯è§†åŒ–</h2>
            <p><strong>å½“å‰æ­¥éª¤ï¼š</strong> <span id="current-step">åˆå§‹åŒ–åœºæ™¯</span></p>
            <div id="progress-bar">
                <div id="progress-fill"></div>
            </div>
            <p id="step-description">æ­£åœ¨è®¾ç½®ä¸‰ç»´ç©ºé—´ä¸­çš„çƒå¯¹ç§°å‘æ•£åœº...</p>
        </div>
        
        <div id="controls">
            <h3>ğŸ® äº¤äº’æ§åˆ¶</h3>
            <button class="button" onclick="startAnimation()">â–¶ï¸ å¼€å§‹åŠ¨ç”»</button>
            <button class="button" onclick="pauseAnimation()">â¸ï¸ æš‚åœ</button>
            <button class="button" onclick="resetAnimation()">ğŸ”„ é‡ç½®</button>
            <br><br>
            
            <label>ç§¯åˆ†è¿›åº¦: <span id="integral-value">0</span></label>
            <input type="range" class="slider" id="integral-slider" min="0" max="100" value="0" oninput="updateIntegral(this.value)">
            
            <label>è§†è§’æ—‹è½¬é€Ÿåº¦: <span id="rotation-speed">1</span></label>
            <input type="range" class="slider" id="rotation-slider" min="0" max="5" value="1" step="0.1" oninput="updateRotationSpeed(this.value)">
            
            <label>åœºå¼ºå¯è§†åŒ–å¼ºåº¦:</label>
            <input type="range" class="slider" id="field-intensity" min="0.1" max="2" value="1" step="0.1" oninput="updateFieldIntensity(this.value)">
            
            <br>
            <div style="margin-top: 15px;">
                <input type="checkbox" id="show-vectors" checked onchange="toggleVectors()"> æ˜¾ç¤ºåœºçŸ¢é‡<br>
                <input type="checkbox" id="show-projection" checked onchange="toggleProjection()"> æ˜¾ç¤ºæŠ•å½±å¹³é¢<br>
                <input type="checkbox" id="show-integration" checked onchange="toggleIntegration()"> æ˜¾ç¤ºç§¯åˆ†åŒºåŸŸ
            </div>
        </div>
        
        <div id="math-panel">
            <h3 style="color: #667eea; margin-top: 0;">ğŸ“ æ•°å­¦æ¨å¯¼è¿‡ç¨‹</h3>
            <div id="math-content">
                <div class="math-formula">
                    <strong>æ­¥éª¤1ï¼šç«‹ä½“è§’ç§¯åˆ†è®¾ç½®</strong><br>
                    $$\int \sin\theta \, d\Omega = \int_0^{2\pi} d\phi \int_0^{\pi} \sin\theta (\sin\theta \, d\theta)$$
                </div>
                <div class="math-formula">
                    <strong>æ­¥éª¤2ï¼šçƒåæ ‡ç§¯åˆ†</strong><br>
                    $$= 2\pi \int_0^{\pi} \sin^2\theta \, d\theta$$
                </div>
                <div class="math-formula">
                    <strong>æ­¥éª¤3ï¼šç§¯åˆ†è®¡ç®—</strong><br>
                    $$= 2\pi \cdot \frac{\pi}{2} = \pi^2$$
                </div>
                <div class="math-formula">
                    <strong>æ­¥éª¤4ï¼šå‡ ä½•å› å­æ¨å¯¼</strong><br>
                    $$\text{å‡ ä½•å› å­} = \frac{\pi^2}{2\pi} \cdot \frac{4\pi}{\pi^2} = 2$$
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let sphereField, projectionPlane, vectorField = [];
        let animationId;
        let isAnimating = false;
        let integralProgress = 0;
        let rotationSpeed = 1;
        let fieldIntensity = 1;
        
        // ç‰©ç†å¸¸æ•°å’Œå‚æ•°
        const MASS_M_POS = new THREE.Vector3(-3, 0, 0);
        const MASS_m_POS = new THREE.Vector3(3, 0, 0);
        const FIELD_RADIUS = 4;
        
        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // æ·»åŠ å…‰ç…§
            setupLighting();
            
            // åˆ›å»ºç‰©ç†å¯¹è±¡
            createMasses();
            createSphericalField();
            createProjectionPlane();
            createVectorField();
            createIntegrationVisualization();
            
            // æ·»åŠ é¼ æ ‡æ§åˆ¶
            setupControls();
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
            
            updateStepInfo(0, "åœºæ™¯åˆå§‹åŒ–å®Œæˆ", "ä¸‰ç»´ç©ºé—´ä¸­çš„çƒå¯¹ç§°å‘æ•£åœºå·²è®¾ç½®å®Œæ¯•");
        }
        
        function setupLighting() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // ç‚¹å…‰æºï¼ˆç”¨äºçªå‡ºè´¨é‡ï¼‰
            const pointLight1 = new THREE.PointLight(0xff4444, 1, 10);
            pointLight1.position.copy(MASS_M_POS);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x4444ff, 1, 10);
            pointLight2.position.copy(MASS_m_POS);
            scene.add(pointLight2);
        }
        
        function createMasses() {
            // è´¨é‡Mï¼ˆå¤§è´¨é‡ï¼‰
            const massM_geometry = new THREE.SphereGeometry(0.4, 32, 32);
            const massM_material = new THREE.MeshPhongMaterial({ 
                color: 0xff4444,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const massM = new THREE.Mesh(massM_geometry, massM_material);
            massM.position.copy(MASS_M_POS);
            massM.castShadow = true;
            scene.add(massM);
            
            // è´¨é‡mï¼ˆå°è´¨é‡ï¼‰
            const massm_geometry = new THREE.SphereGeometry(0.25, 32, 32);
            const massm_material = new THREE.MeshPhongMaterial({ 
                color: 0x4444ff,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const massm = new THREE.Mesh(massm_geometry, massm_material);
            massm.position.copy(MASS_m_POS);
            massm.castShadow = true;
            scene.add(massm);
            
            // æ·»åŠ æ ‡ç­¾
            createLabel("M (å¤§è´¨é‡)", MASS_M_POS, 0xff4444);
            createLabel("m (å°è´¨é‡)", MASS_m_POS, 0x4444ff);
        }
        
        function createSphericalField() {
            sphereField = new THREE.Group();
            
            // åˆ›å»ºå¤šå±‚çƒé¢è¡¨ç¤ºå‘æ•£åœº
            for (let i = 1; i <= 6; i++) {
                const radius = i * 0.8;
                const geometry = new THREE.SphereGeometry(radius, 32, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.1 - i * 0.02, 0.8, 0.5),
                    transparent: true,
                    opacity: 0.15 - i * 0.02,
                    wireframe: true
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(MASS_M_POS);
                sphereField.add(sphere);
            }
            
            scene.add(sphereField);
        }
        
        function createProjectionPlane() {
            // åˆ›å»ºç›¸äº’ä½œç”¨å¹³é¢ï¼ˆz=0ï¼‰
            const planeGeometry = new THREE.PlaneGeometry(10, 8);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            projectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            projectionPlane.rotation.x = Math.PI / 2;
            projectionPlane.receiveShadow = true;
            scene.add(projectionPlane);
            
            // æ·»åŠ ç½‘æ ¼
            const gridHelper = new THREE.GridHelper(10, 20, 0x44ff44, 0x44ff44);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.5;
            scene.add(gridHelper);
        }
        
        function createVectorField() {
            vectorField = [];
            const vectorCount = 50;
            
            for (let i = 0; i < vectorCount; i++) {
                // éšæœºç”Ÿæˆçƒé¢ä¸Šçš„ç‚¹
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                const direction = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                );
                
                const origin = MASS_M_POS.clone();
                const destination = origin.clone().add(direction.multiplyScalar(3));
                
                // åˆ›å»ºç®­å¤´
                const arrowHelper = new THREE.ArrowHelper(
                    direction.normalize(),
                    origin,
                    3,
                    0xffaa00,
                    0.5,
                    0.3
                );
                
                arrowHelper.userData = { theta: theta, phi: phi, originalDirection: direction.clone() };
                vectorField.push(arrowHelper);
                scene.add(arrowHelper);
            }
        }
        
        function createIntegrationVisualization() {
            // åˆ›å»ºç§¯åˆ†åŒºåŸŸå¯è§†åŒ–
            const integrationGroup = new THREE.Group();
            
            // åˆ›å»ºçƒé¢æ‰‡å½¢æ¥è¡¨ç¤ºç§¯åˆ†åŒºåŸŸ
            for (let i = 0; i < 20; i++) {
                const theta = (i / 20) * Math.PI * 2;
                const geometry = new THREE.ConeGeometry(0.1, 2, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(theta / (Math.PI * 2), 1, 0.5),
                    transparent: true,
                    opacity: 0.6
                });
                
                const cone = new THREE.Mesh(geometry, material);
                cone.position.copy(MASS_M_POS);
                cone.lookAt(MASS_M_POS.clone().add(new THREE.Vector3(
                    Math.cos(theta),
                    Math.sin(theta),
                    0
                )));
                
                integrationGroup.add(cone);
            }
            
            scene.add(integrationGroup);
            window.integrationGroup = integrationGroup;
        }
        
        function createLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.font = 'Bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.position.y += 1;
            sprite.scale.set(2, 0.5, 1);
            
            scene.add(sprite);
        }
        
        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            const canvas = document.getElementById('canvas');
            
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y
                    };
                    
                    // æ—‹è½¬ç›¸æœº
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaMove.x * 0.01;
                    spherical.phi += deltaMove.y * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(5, 50);
            });
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            if (isAnimating) {
                // æ—‹è½¬çƒé¢åœº
                if (sphereField) {
                    sphereField.rotation.y += 0.01 * rotationSpeed;
                }
                
                // æ›´æ–°çŸ¢é‡åœºåŠ¨ç”»
                updateVectorFieldAnimation();
                
                // æ›´æ–°ç§¯åˆ†å¯è§†åŒ–
                updateIntegrationVisualization();
            }
            
            renderer.render(scene, camera);
        }
        
        function updateVectorFieldAnimation() {
            const time = Date.now() * 0.001;
            
            vectorField.forEach((arrow, index) => {
                const userData = arrow.userData;
                const phase = (index / vectorField.length) * Math.PI * 2;
                const intensity = (Math.sin(time + phase) + 1) * 0.5;
                
                // æ›´æ–°ç®­å¤´çš„é€æ˜åº¦å’Œé•¿åº¦
                arrow.setLength(2 + intensity * 2, 0.5, 0.3);
                arrow.line.material.opacity = 0.3 + intensity * 0.7;
                arrow.cone.material.opacity = 0.3 + intensity * 0.7;
            });
        }
        
        function updateIntegrationVisualization() {
            if (window.integrationGroup) {
                const progress = integralProgress / 100;
                window.integrationGroup.children.forEach((cone, index) => {
                    const shouldShow = (index / window.integrationGroup.children.length) < progress;
                    cone.visible = shouldShow;
                    
                    if (shouldShow) {
                        cone.material.opacity = 0.6 + Math.sin(Date.now() * 0.005 + index) * 0.2;
                    }
                });
            }
        }
        
        // æ§åˆ¶å‡½æ•°
        function startAnimation() {
            isAnimating = true;
            updateStepInfo(25, "å¼€å§‹ç§¯åˆ†è®¡ç®—", "æ­£åœ¨è®¡ç®—ç«‹ä½“è§’ç§¯åˆ† âˆ«sin Î¸ dÎ©");
        }
        
        function pauseAnimation() {
            isAnimating = false;
            updateStepInfo(50, "åŠ¨ç”»å·²æš‚åœ", "å¯ä»¥æ‰‹åŠ¨è°ƒèŠ‚å‚æ•°è§‚å¯Ÿæ•ˆæœ");
        }
        
        function resetAnimation() {
            isAnimating = false;
            integralProgress = 0;
            document.getElementById('integral-slider').value = 0;
            updateIntegral(0);
            updateStepInfo(0, "é‡ç½®å®Œæˆ", "åœºæ™¯å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€");
        }
        
        function updateIntegral(value) {
            integralProgress = parseFloat(value);
            document.getElementById('integral-value').textContent = (integralProgress / 100 * Math.PI * Math.PI).toFixed(3);
            
            // æ›´æ–°è¿›åº¦æ¡
            document.getElementById('progress-fill').style.width = integralProgress + '%';
            
            // æ›´æ–°æ­¥éª¤ä¿¡æ¯
            if (integralProgress < 25) {
                updateStepInfo(integralProgress, "è®¾ç½®ç§¯åˆ†åŒºåŸŸ", "å®šä¹‰çƒåæ ‡ç³»ä¸­çš„ç§¯åˆ†èŒƒå›´");
            } else if (integralProgress < 50) {
                updateStepInfo(integralProgress, "æ‰§è¡ŒÏ†ç§¯åˆ†", "âˆ«â‚€Â²Ï€ dÏ† = 2Ï€");
            } else if (integralProgress < 75) {
                updateStepInfo(integralProgress, "æ‰§è¡ŒÎ¸ç§¯åˆ†", "âˆ«â‚€Ï€ sinÂ²Î¸ dÎ¸ = Ï€/2");
            } else {
                updateStepInfo(integralProgress, "è®¡ç®—å‡ ä½•å› å­", "æœ€ç»ˆç»“æœï¼šå‡ ä½•å› å­ = 2");
            }
            
            // æ›´æ–°æ•°å­¦å…¬å¼é«˜äº®
            updateMathHighlight(integralProgress);
        }
        
        function updateRotationSpeed(value) {
            rotationSpeed = parseFloat(value);
            document.getElementById('rotation-speed').textContent = value;
        }
        
        function updateFieldIntensity(value) {
            fieldIntensity = parseFloat(value);
            
            // æ›´æ–°åœºå¼ºå¯è§†åŒ–
            vectorField.forEach(arrow => {
                arrow.line.material.opacity *= fieldIntensity;
                arrow.cone.material.opacity *= fieldIntensity;
            });
        }
        
        function toggleVectors() {
            const show = document.getElementById('show-vectors').checked;
            vectorField.forEach(arrow => {
                arrow.visible = show;
            });
        }
        
        function toggleProjection() {
            const show = document.getElementById('show-projection').checked;
            projectionPlane.visible = show;
        }
        
        function toggleIntegration() {
            const show = document.getElementById('show-integration').checked;
            if (window.integrationGroup) {
                window.integrationGroup.visible = show;
            }
        }
        
        function updateStepInfo(progress, step, description) {
            document.getElementById('current-step').textContent = step;
            document.getElementById('step-description').textContent = description;
            document.getElementById('progress-fill').style.width = progress + '%';
        }
        
        function updateMathHighlight(progress) {
            const formulas = document.querySelectorAll('.math-formula');
            formulas.forEach((formula, index) => {
                formula.style.background = '#f8f9fa';
                formula.style.borderLeft = '4px solid #667eea';
            });
            
            // æ ¹æ®è¿›åº¦é«˜äº®å½“å‰å…¬å¼
            const currentFormula = Math.floor(progress / 25);
            if (formulas[currentFormula]) {
                formulas[currentFormula].style.background = 'linear-gradient(45deg, #ff6b6b, #feca57)';
                formulas[currentFormula].style.borderLeft = '4px solid #ff6b6b';
            }
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            initScene();
            
            // ç­‰å¾…MathJaxåŠ è½½å®Œæˆåæ¸²æŸ“æ•°å­¦å…¬å¼
            setTimeout(() => {
                if (window.MathJax) {
                    MathJax.typesetPromise();
                }
            }, 1000);
        });
    </script>
</body>
</html>
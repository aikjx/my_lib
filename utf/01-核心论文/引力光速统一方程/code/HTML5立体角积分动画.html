<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>立体角积分与几何因子推导 - 交互式3D可视化</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            color: white;
            min-width: 250px;
        }
        
        #math-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            backdrop-filter: blur(10px);
        }
        
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .math-formula {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        
        .highlight {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        #progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui-panel">
            <h2 style="color: #667eea; margin-top: 0;">🌌 立体角积分可视化</h2>
            <p><strong>当前步骤：</strong> <span id="current-step">初始化场景</span></p>
            <div id="progress-bar">
                <div id="progress-fill"></div>
            </div>
            <p id="step-description">正在设置三维空间中的球对称发散场...</p>
        </div>
        
        <div id="controls">
            <h3>🎮 交互控制</h3>
            <button class="button" onclick="startAnimation()">▶️ 开始动画</button>
            <button class="button" onclick="pauseAnimation()">⏸️ 暂停</button>
            <button class="button" onclick="resetAnimation()">🔄 重置</button>
            <br><br>
            
            <label>积分进度: <span id="integral-value">0</span></label>
            <input type="range" class="slider" id="integral-slider" min="0" max="100" value="0" oninput="updateIntegral(this.value)">
            
            <label>视角旋转速度: <span id="rotation-speed">1</span></label>
            <input type="range" class="slider" id="rotation-slider" min="0" max="5" value="1" step="0.1" oninput="updateRotationSpeed(this.value)">
            
            <label>场强可视化强度:</label>
            <input type="range" class="slider" id="field-intensity" min="0.1" max="2" value="1" step="0.1" oninput="updateFieldIntensity(this.value)">
            
            <br>
            <div style="margin-top: 15px;">
                <input type="checkbox" id="show-vectors" checked onchange="toggleVectors()"> 显示场矢量<br>
                <input type="checkbox" id="show-projection" checked onchange="toggleProjection()"> 显示投影平面<br>
                <input type="checkbox" id="show-integration" checked onchange="toggleIntegration()"> 显示积分区域
            </div>
        </div>
        
        <div id="math-panel">
            <h3 style="color: #667eea; margin-top: 0;">📐 数学推导过程</h3>
            <div id="math-content">
                <div class="math-formula">
                    <strong>步骤1：立体角积分设置</strong><br>
                    $$\int \sin\theta \, d\Omega = \int_0^{2\pi} d\phi \int_0^{\pi} \sin\theta (\sin\theta \, d\theta)$$
                </div>
                <div class="math-formula">
                    <strong>步骤2：球坐标积分</strong><br>
                    $$= 2\pi \int_0^{\pi} \sin^2\theta \, d\theta$$
                </div>
                <div class="math-formula">
                    <strong>步骤3：积分计算</strong><br>
                    $$= 2\pi \cdot \frac{\pi}{2} = \pi^2$$
                </div>
                <div class="math-formula">
                    <strong>步骤4：几何因子推导</strong><br>
                    $$\text{几何因子} = \frac{\pi^2}{2\pi} \cdot \frac{4\pi}{\pi^2} = 2$$
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let sphereField, projectionPlane, vectorField = [];
        let animationId;
        let isAnimating = false;
        let integralProgress = 0;
        let rotationSpeed = 1;
        let fieldIntensity = 1;
        
        // 物理常数和参数
        const MASS_M_POS = new THREE.Vector3(-3, 0, 0);
        const MASS_m_POS = new THREE.Vector3(3, 0, 0);
        const FIELD_RADIUS = 4;
        
        // 初始化场景
        function initScene() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            
            // 创建渲染器
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // 添加光照
            setupLighting();
            
            // 创建物理对象
            createMasses();
            createSphericalField();
            createProjectionPlane();
            createVectorField();
            createIntegrationVisualization();
            
            // 添加鼠标控制
            setupControls();
            
            // 开始渲染循环
            animate();
            
            updateStepInfo(0, "场景初始化完成", "三维空间中的球对称发散场已设置完毕");
        }
        
        function setupLighting() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // 主光源
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 点光源（用于突出质量）
            const pointLight1 = new THREE.PointLight(0xff4444, 1, 10);
            pointLight1.position.copy(MASS_M_POS);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x4444ff, 1, 10);
            pointLight2.position.copy(MASS_m_POS);
            scene.add(pointLight2);
        }
        
        function createMasses() {
            // 质量M（大质量）
            const massM_geometry = new THREE.SphereGeometry(0.4, 32, 32);
            const massM_material = new THREE.MeshPhongMaterial({ 
                color: 0xff4444,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const massM = new THREE.Mesh(massM_geometry, massM_material);
            massM.position.copy(MASS_M_POS);
            massM.castShadow = true;
            scene.add(massM);
            
            // 质量m（小质量）
            const massm_geometry = new THREE.SphereGeometry(0.25, 32, 32);
            const massm_material = new THREE.MeshPhongMaterial({ 
                color: 0x4444ff,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const massm = new THREE.Mesh(massm_geometry, massm_material);
            massm.position.copy(MASS_m_POS);
            massm.castShadow = true;
            scene.add(massm);
            
            // 添加标签
            createLabel("M (大质量)", MASS_M_POS, 0xff4444);
            createLabel("m (小质量)", MASS_m_POS, 0x4444ff);
        }
        
        function createSphericalField() {
            sphereField = new THREE.Group();
            
            // 创建多层球面表示发散场
            for (let i = 1; i <= 6; i++) {
                const radius = i * 0.8;
                const geometry = new THREE.SphereGeometry(radius, 32, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.1 - i * 0.02, 0.8, 0.5),
                    transparent: true,
                    opacity: 0.15 - i * 0.02,
                    wireframe: true
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(MASS_M_POS);
                sphereField.add(sphere);
            }
            
            scene.add(sphereField);
        }
        
        function createProjectionPlane() {
            // 创建相互作用平面（z=0）
            const planeGeometry = new THREE.PlaneGeometry(10, 8);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            projectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            projectionPlane.rotation.x = Math.PI / 2;
            projectionPlane.receiveShadow = true;
            scene.add(projectionPlane);
            
            // 添加网格
            const gridHelper = new THREE.GridHelper(10, 20, 0x44ff44, 0x44ff44);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.5;
            scene.add(gridHelper);
        }
        
        function createVectorField() {
            vectorField = [];
            const vectorCount = 50;
            
            for (let i = 0; i < vectorCount; i++) {
                // 随机生成球面上的点
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                const direction = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                );
                
                const origin = MASS_M_POS.clone();
                const destination = origin.clone().add(direction.multiplyScalar(3));
                
                // 创建箭头
                const arrowHelper = new THREE.ArrowHelper(
                    direction.normalize(),
                    origin,
                    3,
                    0xffaa00,
                    0.5,
                    0.3
                );
                
                arrowHelper.userData = { theta: theta, phi: phi, originalDirection: direction.clone() };
                vectorField.push(arrowHelper);
                scene.add(arrowHelper);
            }
        }
        
        function createIntegrationVisualization() {
            // 创建积分区域可视化
            const integrationGroup = new THREE.Group();
            
            // 创建球面扇形来表示积分区域
            for (let i = 0; i < 20; i++) {
                const theta = (i / 20) * Math.PI * 2;
                const geometry = new THREE.ConeGeometry(0.1, 2, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(theta / (Math.PI * 2), 1, 0.5),
                    transparent: true,
                    opacity: 0.6
                });
                
                const cone = new THREE.Mesh(geometry, material);
                cone.position.copy(MASS_M_POS);
                cone.lookAt(MASS_M_POS.clone().add(new THREE.Vector3(
                    Math.cos(theta),
                    Math.sin(theta),
                    0
                )));
                
                integrationGroup.add(cone);
            }
            
            scene.add(integrationGroup);
            window.integrationGroup = integrationGroup;
        }
        
        function createLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.font = 'Bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.position.y += 1;
            sprite.scale.set(2, 0.5, 1);
            
            scene.add(sprite);
        }
        
        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            const canvas = document.getElementById('canvas');
            
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y
                    };
                    
                    // 旋转相机
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaMove.x * 0.01;
                    spherical.phi += deltaMove.y * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(5, 50);
            });
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            if (isAnimating) {
                // 旋转球面场
                if (sphereField) {
                    sphereField.rotation.y += 0.01 * rotationSpeed;
                }
                
                // 更新矢量场动画
                updateVectorFieldAnimation();
                
                // 更新积分可视化
                updateIntegrationVisualization();
            }
            
            renderer.render(scene, camera);
        }
        
        function updateVectorFieldAnimation() {
            const time = Date.now() * 0.001;
            
            vectorField.forEach((arrow, index) => {
                const userData = arrow.userData;
                const phase = (index / vectorField.length) * Math.PI * 2;
                const intensity = (Math.sin(time + phase) + 1) * 0.5;
                
                // 更新箭头的透明度和长度
                arrow.setLength(2 + intensity * 2, 0.5, 0.3);
                arrow.line.material.opacity = 0.3 + intensity * 0.7;
                arrow.cone.material.opacity = 0.3 + intensity * 0.7;
            });
        }
        
        function updateIntegrationVisualization() {
            if (window.integrationGroup) {
                const progress = integralProgress / 100;
                window.integrationGroup.children.forEach((cone, index) => {
                    const shouldShow = (index / window.integrationGroup.children.length) < progress;
                    cone.visible = shouldShow;
                    
                    if (shouldShow) {
                        cone.material.opacity = 0.6 + Math.sin(Date.now() * 0.005 + index) * 0.2;
                    }
                });
            }
        }
        
        // 控制函数
        function startAnimation() {
            isAnimating = true;
            updateStepInfo(25, "开始积分计算", "正在计算立体角积分 ∫sin θ dΩ");
        }
        
        function pauseAnimation() {
            isAnimating = false;
            updateStepInfo(50, "动画已暂停", "可以手动调节参数观察效果");
        }
        
        function resetAnimation() {
            isAnimating = false;
            integralProgress = 0;
            document.getElementById('integral-slider').value = 0;
            updateIntegral(0);
            updateStepInfo(0, "重置完成", "场景已重置到初始状态");
        }
        
        function updateIntegral(value) {
            integralProgress = parseFloat(value);
            document.getElementById('integral-value').textContent = (integralProgress / 100 * Math.PI * Math.PI).toFixed(3);
            
            // 更新进度条
            document.getElementById('progress-fill').style.width = integralProgress + '%';
            
            // 更新步骤信息
            if (integralProgress < 25) {
                updateStepInfo(integralProgress, "设置积分区域", "定义球坐标系中的积分范围");
            } else if (integralProgress < 50) {
                updateStepInfo(integralProgress, "执行φ积分", "∫₀²π dφ = 2π");
            } else if (integralProgress < 75) {
                updateStepInfo(integralProgress, "执行θ积分", "∫₀π sin²θ dθ = π/2");
            } else {
                updateStepInfo(integralProgress, "计算几何因子", "最终结果：几何因子 = 2");
            }
            
            // 更新数学公式高亮
            updateMathHighlight(integralProgress);
        }
        
        function updateRotationSpeed(value) {
            rotationSpeed = parseFloat(value);
            document.getElementById('rotation-speed').textContent = value;
        }
        
        function updateFieldIntensity(value) {
            fieldIntensity = parseFloat(value);
            
            // 更新场强可视化
            vectorField.forEach(arrow => {
                arrow.line.material.opacity *= fieldIntensity;
                arrow.cone.material.opacity *= fieldIntensity;
            });
        }
        
        function toggleVectors() {
            const show = document.getElementById('show-vectors').checked;
            vectorField.forEach(arrow => {
                arrow.visible = show;
            });
        }
        
        function toggleProjection() {
            const show = document.getElementById('show-projection').checked;
            projectionPlane.visible = show;
        }
        
        function toggleIntegration() {
            const show = document.getElementById('show-integration').checked;
            if (window.integrationGroup) {
                window.integrationGroup.visible = show;
            }
        }
        
        function updateStepInfo(progress, step, description) {
            document.getElementById('current-step').textContent = step;
            document.getElementById('step-description').textContent = description;
            document.getElementById('progress-fill').style.width = progress + '%';
        }
        
        function updateMathHighlight(progress) {
            const formulas = document.querySelectorAll('.math-formula');
            formulas.forEach((formula, index) => {
                formula.style.background = '#f8f9fa';
                formula.style.borderLeft = '4px solid #667eea';
            });
            
            // 根据进度高亮当前公式
            const currentFormula = Math.floor(progress / 25);
            if (formulas[currentFormula]) {
                formulas[currentFormula].style.background = 'linear-gradient(45deg, #ff6b6b, #feca57)';
                formulas[currentFormula].style.borderLeft = '4px solid #ff6b6b';
            }
        }
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 页面加载完成后初始化
        window.addEventListener('load', () => {
            initScene();
            
            // 等待MathJax加载完成后渲染数学公式
            setTimeout(() => {
                if (window.MathJax) {
                    MathJax.typesetPromise();
                }
            }, 1000);
        });
    </script>
</body>
</html>
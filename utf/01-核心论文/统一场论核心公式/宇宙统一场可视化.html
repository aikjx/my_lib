<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>张祥前统一场论 - 宇宙统一场可视化</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            overflow: hidden; color: white; height: 100vh;
        }
        
        #canvas { 
            display: block; cursor: grab; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0c0c0c 100%);
        }
        
        .ui-panel {
            position: absolute; background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px; padding: 20px; 
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }
        
        .ui-panel:hover { transform: translateY(-2px); }
        
        #info-panel { 
            top: 20px; left: 20px; width: 450px; max-height: 80vh; overflow-y: auto;
        }
        
        #controls-panel { 
            top: 20px; right: 20px; width: 350px;
        }
        
        #formula-panel {
            bottom: 20px; left: 20px; width: 600px; max-height: 300px; overflow-y: auto;
        }
        
        .panel-title {
            font-size: 1.5em; font-weight: bold; margin-bottom: 15px;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            background-clip: text; -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }
        
        .control-button {
            background: linear-gradient(45deg, #667eea, #764ba2); color: white; 
            border: none; padding: 12px 24px; border-radius: 25px; 
            cursor: pointer; margin: 5px; font-size: 0.9em;
            transition: all 0.3s ease; font-weight: 500;
        }
        
        .control-button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        
        .formula-item {
            background: rgba(255, 255, 255, 0.05); padding: 10px; 
            border-radius: 8px; margin: 8px 0; border-left: 4px solid #667eea;
            cursor: pointer; transition: all 0.3s ease;
        }
        
        .formula-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }
        
        .formula-item.active {
            background: rgba(102, 126, 234, 0.2);
            border-left-color: #f093fb;
        }
        
        .cosmic-insight {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid rgba(102, 126, 234, 0.3); padding: 15px; 
            border-radius: 10px; margin: 15px 0;
        }
        
        .cosmic-insight h4 {
            color: #667eea; margin-bottom: 8px; font-size: 1.1em;
        }
        
        .loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 0.5s ease;
        }
        
        .loading-spinner {
            width: 80px; height: 80px; border: 6px solid rgba(255,255,255,0.1);
            border-top: 6px solid #667eea; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 30px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .fade-out { opacity: 0; pointer-events: none; }
        
        .stats-display {
            background: rgba(255, 255, 255, 0.05); padding: 10px; 
            border-radius: 8px; margin: 10px 0; font-family: monospace;
            font-size: 0.85em; line-height: 1.4;
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .ui-panel { width: calc(100% - 40px) !important; }
            #controls-panel { top: auto; bottom: 20px; right: 20px; }
            #formula-panel { display: none; }
        }
    </style>
    
    <!-- 外部库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
</head>
<body>
    <!-- 加载屏幕 -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-spinner"></div>
        <h1>🌌 张祥前统一场论</h1>
        <h2>宇宙统一场可视化系统</h2>
        <p>正在构建宇宙的数学结构...</p>
    </div>
    
    <!-- 主画布 -->
    <canvas id="canvas"></canvas>
    
    <!-- 信息面板 -->
    <div id="info-panel" class="ui-panel">
        <div class="panel-title">🌌 宇宙统一场论</div>
        
        <div class="cosmic-insight">
            <h4>🔬 核心理念</h4>
            <p>张祥前统一场论认为，宇宙中的一切现象都源于<strong>空间以光速进行螺旋运动</strong>这一基本事实。时间、质量、力场都是这种运动的不同表现形式。</p>
        </div>
        
        <div class="cosmic-insight">
            <h4>🌟 理论突破</h4>
            <p>• <strong>时空统一</strong>：时间是空间运动的度量<br>
            • <strong>质量几何化</strong>：质量是空间扭曲的度量<br>
            • <strong>四力统一</strong>：所有力都源于同一方程<br>
            • <strong>常数关联</strong>：G与c存在深层数学关系</p>
        </div>
        
        <div class="cosmic-insight">
            <h4>🚀 技术预言</h4>
            <p>• <strong>反重力技术</strong>：通过质量变化产生推力<br>
            • <strong>光速飞行</strong>：基于统一场原理的推进<br>
            • <strong>场操控</strong>：引力与电磁的相互转化<br>
            • <strong>时空工程</strong>：对时空结构的直接操作</p>
        </div>
        
        <div class="stats-display" id="statsDisplay">
            <strong>实时统计：</strong><br>
            活跃公式: <span id="activeFormulas">19</span><br>
            场强度: <span id="fieldStrength">100%</span><br>
            统一度: <span id="unificationLevel">完全统一</span><br>
            宇宙和谐度: <span id="cosmicHarmony">∞</span>
        </div>
    </div>
    
    <!-- 控制面板 -->
    <div id="controls-panel" class="ui-panel">
        <div class="panel-title">🎮 宇宙控制台</div>
        
        <div style="text-align: center; margin-bottom: 15px;">
            <button class="control-button" onclick="toggleAnimation()">
                <span id="playPauseIcon">▶️</span> <span id="playPauseText">启动宇宙</span>
            </button>
            <button class="control-button" onclick="resetUniverse()">🔄 重置宇宙</button>
            <button class="control-button" onclick="toggleFullscreen()">🔍 全屏观测</button>
        </div>
        
        <div class="cosmic-insight">
            <h4>🎛️ 场控制</h4>
            <button class="control-button" onclick="focusFormula('spacetime')">时空场</button>
            <button class="control-button" onclick="focusFormula('gravity')">引力场</button>
            <button class="control-button" onclick="focusFormula('electromagnetic')">电磁场</button>
            <button class="control-button" onclick="focusFormula('unified')">统一场</button>
        </div>
        
        <div class="cosmic-insight">
            <h4>🌌 观测模式</h4>
            <button class="control-button" onclick="setViewMode('overview')">全景视图</button>
            <button class="control-button" onclick="setViewMode('detailed')">细节视图</button>
            <button class="control-button" onclick="setViewMode('mathematical')">数学视图</button>
        </div>
        
        <div class="cosmic-insight">
            <h4>💡 操作指南</h4>
            <p>• 鼠标拖拽旋转宇宙<br>
            • 滚轮缩放观测距离<br>
            • 点击公式球体查看详情<br>
            • 观察场的相互作用</p>
        </div>
    </div>
    
    <!-- 公式面板 -->
    <div id="formula-panel" class="ui-panel">
        <div class="panel-title">📐 核心公式导航</div>
        <div id="formulaList">
            <!-- 公式列表将由JavaScript动态生成 -->
        </div>
    </div>

    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let animationId, isAnimating = false;
        let universeObjects = {};
        let startTime = Date.now();
        let currentFocus = 'all';
        let viewMode = 'overview';
        
        // 公式数据
        const formulas = [
            { id: '01', name: '时空同一化方程', category: 'spacetime', color: 0xffffff, position: [0, 0, 0] },
            { id: '02', name: '三维螺旋时空方程', category: 'spacetime', color: 0x667eea, position: [8, 0, 0] },
            { id: '03', name: '质量定义方程', category: 'mass', color: 0xffd700, position: [0, 8, 0] },
            { id: '04', name: '引力场定义方程', category: 'gravity', color: 0xff6b6b, position: [0, 0, 8] },
            { id: '05', name: '静止动量方程', category: 'momentum', color: 0x4ecdc4, position: [-8, 0, 0] },
            { id: '06', name: '运动动量方程', category: 'momentum', color: 0x45b7d1, position: [0, -8, 0] },
            { id: '07', name: '宇宙大统一方程', category: 'unified', color: 0xf093fb, position: [0, 0, -8] },
            { id: '08', name: '空间波动方程', category: 'wave', color: 0x96ceb4, position: [6, 6, 0] },
            { id: '09', name: '电荷定义方程', category: 'electromagnetic', color: 0xfeca57, position: [6, 0, 6] },
            { id: '10', name: '电场定义方程', category: 'electromagnetic', color: 0xff9ff3, position: [0, 6, 6] },
            { id: '11', name: '磁场定义方程', category: 'electromagnetic', color: 0x54a0ff, position: [-6, 6, 0] },
            { id: '12', name: '变化引力场产生电磁场', category: 'coupling', color: 0xff6348, position: [-6, 0, 6] },
            { id: '13', name: '磁矢势方程', category: 'electromagnetic', color: 0x5f27cd, position: [0, -6, 6] },
            { id: '14', name: '变化引力场产生电场', category: 'coupling', color: 0x00d2d3, position: [6, -6, 0] },
            { id: '15', name: '变化磁场产生引力场和电场', category: 'coupling', color: 0xff9f43, position: [6, 0, -6] },
            { id: '16', name: '统一场论能量方程', category: 'energy', color: 0xee5a24, position: [0, 6, -6] },
            { id: '17', name: '光速飞行器动力学方程', category: 'propulsion', color: 0x0abde3, position: [-6, -6, 0] },
            { id: '18', name: '空间波动通解', category: 'wave', color: 0x006ba6, position: [-6, 0, -6] },
            { id: '19', name: '引力光速统一方程', category: 'constants', color: 0xc44569, position: [0, -6, -6] }
        ];
        
        // 场景初始化
        function initUniverse() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 100, 300);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'), 
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // 创建控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 200;
            controls.minDistance = 10;
            
            // 设置宇宙环境
            setupUniverseEnvironment();
            
            // 创建公式球体
            createFormulaSpheres();
            
            // 创建连接线
            createConnections();
            
            // 创建统一场效应
            createUnifiedField();
            
            // 生成公式列表
            generateFormulaList();
            
            // 开始宇宙动画
            animateUniverse();
            
            // 隐藏加载屏幕
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('fade-out');
            }, 2000);
        }
        
        // 设置宇宙环境
        function setupUniverseEnvironment() {
            // 宇宙背景光
            const ambientLight = new THREE.AmbientLight(0x404080, 0.2);
            scene.add(ambientLight);
            
            // 中心光源（代表统一场的核心）
            const centralLight = new THREE.PointLight(0xffffff, 2, 100);
            centralLight.position.set(0, 0, 0);
            centralLight.castShadow = true;
            scene.add(centralLight);
            
            // 创建宇宙坐标系
            const axesHelper = new THREE.AxesHelper(15);
            scene.add(axesHelper);
            
            // 创建宇宙网格
            const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
            scene.add(gridHelper);
            
            // 创建星空背景
            createStarField();
        }
        
        // 创建星空背景
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.55, Math.random() * 0.25 + 0.55);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starMaterial = new THREE.PointsMaterial({ 
                size: 0.5, 
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            universeObjects.stars = stars;
        }
        
        // 创建公式球体
        function createFormulaSpheres() {
            const sphereGroup = new THREE.Group();
            
            formulas.forEach((formula, index) => {
                // 创建球体几何
                const geometry = new THREE.SphereGeometry(1.5, 32, 16);
                
                // 创建发光材质
                const material = new THREE.MeshPhongMaterial({ 
                    color: formula.color,
                    emissive: new THREE.Color(formula.color).multiplyScalar(0.2),
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(...formula.position);
                sphere.userData = formula;
                
                // 添加光环效果
                const ringGeometry = new THREE.RingGeometry(2, 2.5, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: formula.color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                sphere.add(ring);
                
                // 添加粒子效应
                createParticleEffect(sphere, formula.color);
                
                sphereGroup.add(sphere);
            });
            
            scene.add(sphereGroup);
            universeObjects.formulaSpheres = sphereGroup;
        }
        
        // 创建粒子效应
        function createParticleEffect(parent, color) {
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const radius = 3 + Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({ 
                color: color,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            parent.add(particles);
        }
        
        // 创建连接线
        function createConnections() {
            const connectionGroup = new THREE.Group();
            
            // 定义公式间的逻辑连接
            const connections = [
                ['01', '02'], ['01', '03'], ['01', '05'], ['01', '08'],
                ['03', '04'], ['03', '09'], ['05', '06'], ['06', '07'],
                ['04', '12'], ['04', '14'], ['09', '10'], ['10', '11'],
                ['11', '13'], ['12', '15'], ['14', '15'], ['07', '16'],
                ['07', '17'], ['08', '18'], ['04', '19']
            ];
            
            connections.forEach(([from, to]) => {
                const fromFormula = formulas.find(f => f.id === from);
                const toFormula = formulas.find(f => f.id === to);
                
                if (fromFormula && toFormula) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        ...fromFormula.position,
                        ...toFormula.position
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0x667eea,
                        transparent: true,
                        opacity: 0.4
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    connectionGroup.add(line);
                }
            });
            
            scene.add(connectionGroup);
            universeObjects.connections = connectionGroup;
        }
        
        // 创建统一场效应
        function createUnifiedField() {
            // 中心统一场球
            const fieldGeometry = new THREE.SphereGeometry(20, 64, 32);
            const fieldMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 0.1 }
                },
                vertexShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        
                        vec3 newPosition = position + normal * sin(time + length(position) * 0.02) * 0.5;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        float r = length(vPosition);
                        float theta = acos(vPosition.z / r);
                        float phi = atan(vPosition.y, vPosition.x);
                        
                        vec3 color = mix(
                            vec3(0.4, 0.5, 1.0),
                            vec3(1.0, 0.6, 0.8),
                            sin(theta * 3.0 + time) * 0.5 + 0.5
                        );
                        
                        float alpha = opacity * (0.5 + sin(time + r * 0.1) * 0.3);
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const unifiedField = new THREE.Mesh(fieldGeometry, fieldMaterial);
            scene.add(unifiedField);
            universeObjects.unifiedField = unifiedField;
        }
        
        // 生成公式列表
        function generateFormulaList() {
            const formulaList = document.getElementById('formulaList');
            
            formulas.forEach(formula => {
                const item = document.createElement('div');
                item.className = 'formula-item';
                item.innerHTML = `
                    <strong>${formula.id}. ${formula.name}</strong><br>
                    <small>类别: ${formula.category}</small>
                `;
                item.onclick = () => focusOnFormula(formula.id);
                formulaList.appendChild(item);
            });
        }
        
        // 主动画循环
        function animateUniverse() {
            animationId = requestAnimationFrame(animateUniverse);
            
            const currentTime = (Date.now() - startTime) / 1000;
            
            if (isAnimating) {
                updateUniverseAnimation(currentTime);
            }
            
            // 更新控制器
            controls.update();
            
            // 渲染宇宙
            renderer.render(scene, camera);
        }
        
        // 更新宇宙动画
        function updateUniverseAnimation(time) {
            // 旋转公式球体
            if (universeObjects.formulaSpheres) {
                universeObjects.formulaSpheres.children.forEach((sphere, index) => {
                    sphere.rotation.y = time * (0.2 + index * 0.01);
                    sphere.rotation.x = time * (0.1 + index * 0.005);
                    
                    // 轻微的上下浮动
                    const originalY = sphere.userData.position[1];
                    sphere.position.y = originalY + Math.sin(time + index) * 0.5;
                });
            }
            
            // 更新统一场
            if (universeObjects.unifiedField) {
                universeObjects.unifiedField.material.uniforms.time.value = time;
                universeObjects.unifiedField.rotation.y = time * 0.05;
            }
            
            // 旋转星空
            if (universeObjects.stars) {
                universeObjects.stars.rotation.y = time * 0.001;
            }
            
            // 更新连接线透明度
            if (universeObjects.connections) {
                universeObjects.connections.children.forEach((line, index) => {
                    line.material.opacity = 0.2 + Math.sin(time + index) * 0.2;
                });
            }
        }
        
        // 聚焦特定公式
        function focusOnFormula(formulaId) {
            const formula = formulas.find(f => f.id === formulaId);
            if (formula) {
                // 移动相机到公式位置
                const targetPosition = new THREE.Vector3(...formula.position);
                targetPosition.multiplyScalar(1.5);
                
                // 平滑移动相机
                const startPosition = camera.position.clone();
                const duration = 2000;
                const startTime = Date.now();
                
                function animateCamera() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    controls.target.lerp(new THREE.Vector3(...formula.position), easeProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCamera);
                    }
                }
                
                animateCamera();
                
                // 高亮选中的公式
                document.querySelectorAll('.formula-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.formula-item')[formulas.findIndex(f => f.id === formulaId)].classList.add('active');
            }
        }
        
        // 聚焦特定类别
        function focusFormula(category) {
            currentFocus = category;
            
            if (universeObjects.formulaSpheres) {
                universeObjects.formulaSpheres.children.forEach(sphere => {
                    const formula = sphere.userData;
                    if (category === 'all' || formula.category === category) {
                        sphere.material.opacity = 0.9;
                        sphere.scale.set(1, 1, 1);
                    } else {
                        sphere.material.opacity = 0.3;
                        sphere.scale.set(0.5, 0.5, 0.5);
                    }
                });
            }
        }
        
        // 设置观测模式
        function setViewMode(mode) {
            viewMode = mode;
            
            switch (mode) {
                case 'overview':
                    camera.position.set(30, 30, 30);
                    controls.target.set(0, 0, 0);
                    break;
                case 'detailed':
                    camera.position.set(15, 15, 15);
                    break;
                case 'mathematical':
                    camera.position.set(50, 0, 0);
                    camera.lookAt(0, 0, 0);
                    break;
            }
        }
        
        // 控制函数
        function toggleAnimation() {
            isAnimating = !isAnimating;
            const icon = document.getElementById('playPauseIcon');
            const text = document.getElementById('playPauseText');
            
            if (isAnimating) {
                icon.textContent = '⏸️';
                text.textContent = '暂停宇宙';
            } else {
                icon.textContent = '▶️';
                text.textContent = '启动宇宙';
            }
        }
        
        function resetUniverse() {
            startTime = Date.now();
            camera.position.set(30, 30, 30);
            controls.target.set(0, 0, 0);
            focusFormula('all');
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 页面加载完成后初始化宇宙
        window.addEventListener('load', () => {
            initUniverse();
        });
    </script>
</body>
</html>